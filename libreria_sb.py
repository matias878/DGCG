# -*- coding: utf-8 -*-
"""libreria_SB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ofk8rc8J8bbijfsBbi3EA3GourjpZkne

librerias
"""

# @title
#!pip install pdfminer-six
#!pip install pymupdf

import re
import fitz  # PyMuPDF
from io import BytesIO
import pandas as pd
from google.colab import files
from pdfminer.high_level import extract_text
from pdfminer.layout import LAParams

"""AYSA"""

# @title
def aysa_simple():
    # simple
    aysa_regiones = [(80,55,570,165),(380,240,570,430),(20,470,370,545)]
    #cargar archivos
    uploaded = files.upload()

    """extraer texto"""

    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def procesar_varios_pdfs(lista_pdfs, regiones, pagina_numero=1):
        """
        Procesa varios archivos PDF y extrae las regiones definidas.

        Args:
        - lista_pdfs (list): Lista de rutas a los archivos PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).
        - pagina_numero (int): Número de la página a analizar (por defecto 1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada PDF.
        """
        # Lista para almacenar los datos de cada PDF
        datos_pdf = []

        # Iterar sobre cada archivo PDF
        for pdf_path in lista_pdfs:
            # Extraer texto de las regiones
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_pdf.append({
                "Archivo": pdf_path,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_pdf)

        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF

    regiones = aysa_regiones  # Coordenadas de

    # Extraer texto de las regiones
    df = procesar_varios_pdfs(lista_pdfs ,regiones , 1)

    # Mostrar el texto extraído de cada región
    #df.head()
    """EXTRAER DATOS ESPECIFICOS"""

    # Numero de Factura  en region 1
    def extraer_numero_factura(texto):
        lsp_pattern = r"LSP\s*-\s*LIQUIDACIÓN\s*DE\s*SERVICIOS\s*PÚBLICOS\s*A\d+\s*Nº\s*(\w+)"
        lsp_number = re.search(lsp_pattern, texto)
        if lsp_number:
            return lsp_number.group(1)
        return None

    # Fecha de emisión en region 1
    def extraer_fecha_emision(texto):
        fecha_emision_pattern = r"Fecha de emisión:\s*(\d{2}/\d{2}/\d{4})"
        fecha_emision = re.search(fecha_emision_pattern, texto)
        if fecha_emision:
            return fecha_emision.group(1)
        return None

    # Fecha de vencimiento en region 1
    def extraer_fecha_vencimiento(texto):
        fecha_vto_pattern = r"Fecha Vto:\s*(\d{2}/\d{2}/\d{4})"
        fecha_vto = re.search(fecha_vto_pattern, texto)
        if fecha_vto:
            return fecha_vto.group(1)
        return None

    # Destinatario en region 1
    def extraer_direccion(texto):
        direccion_pattern = r"\bAL\b\s*([\s\S]*?)(?=\s*LSP)" #después de "AL" y antes de "Cuenta de Servicios"
        direccion = re.search(direccion_pattern, texto, re.DOTALL)
        if direccion:
            direccion_texto = direccion.group(1).strip()
            # Eliminamos cualquier línea en blanco extra al final y reemplazamos saltos de línea por espacios
            direccion_texto = re.sub(r'\n+', ' ', direccion_texto)
            return direccion_texto
        return None
    # Número de cuenta en region 1
    def extraer_cuenta(texto):
        cuenta_pattern = r"Cuenta de Servicios\s*(\d+)"
        cuenta = re.search(cuenta_pattern, texto)
        if cuenta:
            return cuenta.group(1)
        return None

    # Total a pagar en region 2
    def extraer_total(texto):
        total_pattern = r"Total a pagar\n\$ ([\d.,]+)"
        total = re.search(total_pattern, texto)
        if total:
            return total.group(1)
        return None

    # Periodo de facturación en region 2
    def extraer_periodo(texto):
        periodo_pattern = r"Periodo de Facturación Cargos Fijos\n([\d/]+ al [\d/]+)"
        periodo = re.search(periodo_pattern, texto)
        if periodo:
            return periodo.group(1)
        return None

    # Domicilio en region 2
    def extraer_domicilio(texto):
        domicilio_pattern = r"Domicilio de Prestación del Servicio\n([\s\S]*?)(?=\n\s*\n|$)"
        domicilio = re.search(domicilio_pattern, texto, re.DOTALL)
        if domicilio:
            domicilio_texto = domicilio.group(1).strip()
            # Reemplaza múltiples saltos de línea con un solo espacio
            domicilio_texto = re.sub(r'\n+', ' ', domicilio_texto)
            return domicilio_texto
        return None

    # "IVA 27.000%" en region 3
    def menciona_iva_27(texto):
        iva_27_pattern = r"IVA Base\s+Alícuota\s+27\.000%"
        return bool(re.search(iva_27_pattern, texto))

    # "Perc. IVA" en region 3
    def menciona_perc_iva(texto):
        perc_iva_pattern = r"Perc\. IVA"
        return bool(re.search(perc_iva_pattern, texto))


    df['Numero de factura']=df['Region_1'].apply(extraer_numero_factura)
    df['Fecha de Emision ']=df['Region_1'].apply(extraer_fecha_emision)
    df['Fecha de Vencimiento']=df['Region_1'].apply(extraer_fecha_vencimiento)
    df['Destinatario']=df['Region_1'].apply(extraer_direccion)
    df['Cuenta']=df['Region_1'].apply(extraer_cuenta)
    df['Total']=df['Region_2'].apply(extraer_total)
    df['Periodo']=df['Region_2'].apply(extraer_periodo)
    df['Domicilio']=df['Region_2'].apply(extraer_domicilio)
    df['IVA 27%'] = df['Region_3'].apply(menciona_iva_27)
    df['Perc IVA'] = df['Region_3'].apply(menciona_perc_iva)
    #df.head()

    """dar formato a las columnas"""

    df.drop(columns=['Region_1','Region_2','Region_3'],inplace=True)
    df['Total'] = df['Total'].str.replace(',', '.')
    df['Total'] = df['Total'].str.replace('.', '')
    df['Total'] = df['Total'].astype(float)
    df['Fecha de Emision '] = pd.to_datetime(df['Fecha de Emision '], format='%d/%m/%Y')
    df['Fecha de Vencimiento'] = pd.to_datetime(df['Fecha de Vencimiento'], format='%d/%m/%Y')
    df['Cuenta'] = df['Cuenta'].astype(int)
    df['IVA 27%'] = df['IVA 27%'].replace({True: 'Sí', False: 'No'})
    df['Perc IVA'] = df['Perc IVA'].replace({True: 'Sí', False: 'No'})


    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})[A-Za-z](\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)
        return "No encontrado", "No encontrado"

    #verificar el destinatario

    #separar el periodo
    def separar_periodo(periodo):
        try:
            Desde, Hasta = periodo.split(' al ')
            return pd.Series([Desde, Hasta], index=['Desde', 'Hasta'])
        except ValueError:
            return pd.Series([None, None], index=['Desde', 'Hasta'])


    # Aplicar la función y crear nuevas columnas
    df[['sucursal', 'factura']] = df['Numero de factura'].apply(separar_codigo).apply(pd.Series)
    df[['Desde', 'Hasta']] = df['Periodo'].apply(separar_periodo)
    df = df.drop(columns=['Periodo','Numero de factura'])
    df['Desde'] = pd.to_datetime(df['Desde'], format='%d/%m/%Y')
    df['Hasta'] = pd.to_datetime(df['Hasta'], format='%d/%m/%Y')
    df['sucursal'] = df['sucursal'].astype(int)
    df['factura'] = df['factura'].astype(int)

    nuevo_orden = ['sucursal', 'factura','Cuenta','Fecha de Emision ', 'Fecha de Vencimiento', 'Desde', 'Hasta', 'IVA 27%', 'Perc IVA', 'Total', 'Destinatario','Domicilio']
    df = df[nuevo_orden]
    df.head()

    """descargar el excel"""
    nombre = "facturas AySA leidas.xlsx"
    archivo_excel = df.to_excel(nombre, index=False)
    files.download(nombre)

def aysa_unificado():
    # unificado
    aysa_regiones = [(80,55,570,165),(380,240,570,430),(20,470,370,545)]

    uploaded = files.upload()

    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def obtener_numero_paginas(pdf_path):
        """
        Obtiene el número total de páginas en un archivo PDF.

        Args:
        - pdf_path (str): Ruta al archivo PDF.

        Returns:
        - int: Número total de páginas en el PDF.
        """
        with fitz.open(pdf_path) as pdf:
            num_paginas = pdf.page_count
        return num_paginas


    def procesar_pdf_con_varias_paginas(pdf_path, regiones):
        """
        Procesa un archivo PDF con múltiples páginas y extrae las regiones definidas.

        Args:
        - pdf_path (str): Ruta al archivo PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada página del PDF.
        """
        # Lista para almacenar los datos de cada página del PDF
        datos_paginas = []

        # Obtener el número total de páginas del PDF
        num_paginas = obtener_numero_paginas(pdf_path)

        # Iterar sobre cada página del PDF
        for pagina_numero in range(1, num_paginas + 1):
            # Extraer texto de las regiones en la página actual
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_paginas.append({
                "Archivo": pdf_path,
                "Pagina": pagina_numero,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_paginas)

        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF

    file_path = next(iter(uploaded.keys()))

    regiones = aysa_regiones# Coordenadas de

    # Extraer texto de las regiones
    df = procesar_pdf_con_varias_paginas(file_path ,regiones )

    # Mostrar el texto extraído de cada región
    #df.head(10)

    df = df[df['Region_1'].str.strip() != '']
    """EXTRAER DATOS ESPECIFICOS"""

    # Numero de Factura  en region 1
    def extraer_numero_factura(texto):
        lsp_pattern = r"LSP\s*-\s*LIQUIDACIÓN\s*DE\s*SERVICIOS\s*PÚBLICOS\s*A\d+\s*Nº\s*(\w+)"
        lsp_number = re.search(lsp_pattern, texto)
        if lsp_number:
            return lsp_number.group(1)
        return None

    # Fecha de emisión en region 1
    def extraer_fecha_emision(texto):
        fecha_emision_pattern = r"Fecha de emisión:\s*(\d{2}/\d{2}/\d{4})"
        fecha_emision = re.search(fecha_emision_pattern, texto)
        if fecha_emision:
            return fecha_emision.group(1)
        return None

    # Fecha de vencimiento en region 1
    def extraer_fecha_vencimiento(texto):
        fecha_vto_pattern = r"Fecha Vto:\s*(\d{2}/\d{2}/\d{4})"
        fecha_vto = re.search(fecha_vto_pattern, texto)
        if fecha_vto:
            return fecha_vto.group(1)
        return None

    # Destinatario en region 1
    def extraer_direccion(texto):
        direccion_pattern = r"\bAL\b\s*([\s\S]*?)(?=\s*LSP)" #después de "AL" y antes de "Cuenta de Servicios"
        direccion = re.search(direccion_pattern, texto, re.DOTALL)
        if direccion:
            direccion_texto = direccion.group(1).strip()
            # Eliminamos cualquier línea en blanco extra al final y reemplazamos saltos de línea por espacios
            direccion_texto = re.sub(r'\n+', ' ', direccion_texto)
            return direccion_texto
        return None
    # Número de cuenta en region 1
    def extraer_cuenta(texto):
        cuenta_pattern = r"Cuenta de Servicios\s*(\d+)"
        cuenta = re.search(cuenta_pattern, texto)
        if cuenta:
            return cuenta.group(1)
        return None

    # Total a pagar en region 2
    def extraer_total(texto):
        total_pattern = r"Total a pagar\n\$ ([\d.,]+)"
        total = re.search(total_pattern, texto)
        if total:
            return total.group(1)
        return None

    # Periodo de facturación en region 2
    def extraer_periodo(texto):
        periodo_pattern = r"Periodo de Facturación Cargos Fijos\n([\d/]+ al [\d/]+)"
        periodo = re.search(periodo_pattern, texto)
        if periodo:
            return periodo.group(1)
        return None

    # Domicilio en region 2
    def extraer_domicilio(texto):
        domicilio_pattern = r"Domicilio de Prestación del Servicio\n([\s\S]*?)(?=\n\s*\n|$)"
        domicilio = re.search(domicilio_pattern, texto, re.DOTALL)
        if domicilio:
            domicilio_texto = domicilio.group(1).strip()
            # Reemplaza múltiples saltos de línea con un solo espacio
            domicilio_texto = re.sub(r'\n+', ' ', domicilio_texto)
            return domicilio_texto
        return None

    # "IVA 27.000%" en region 3
    def menciona_iva_27(texto):
        iva_27_pattern = r"IVA Base\s+Alícuota\s+27\.000%"
        return bool(re.search(iva_27_pattern, texto))

    # "Perc. IVA" en region 3
    def menciona_perc_iva(texto):
        perc_iva_pattern = r"Perc\. IVA"
        return bool(re.search(perc_iva_pattern, texto))


    df['Numero de factura']=df['Region_1'].apply(extraer_numero_factura)
    df['Fecha de Emision ']=df['Region_1'].apply(extraer_fecha_emision)
    df['Fecha de Vencimiento']=df['Region_1'].apply(extraer_fecha_vencimiento)
    df['Destinatario']=df['Region_1'].apply(extraer_direccion)
    df['Cuenta']=df['Region_1'].apply(extraer_cuenta)
    df['Total']=df['Region_2'].apply(extraer_total)
    df['Periodo']=df['Region_2'].apply(extraer_periodo)
    df['Domicilio']=df['Region_2'].apply(extraer_domicilio)
    df['IVA 27%'] = df['Region_3'].apply(menciona_iva_27)
    df['Perc IVA'] = df['Region_3'].apply(menciona_perc_iva)
    #df.head()
    """dar formato a las columnas"""

    df.drop(columns=['Region_1','Region_2','Region_3'],inplace=True)
    df['Total'] = df['Total'].str.replace(',', '.')
    df['Total'] = df['Total'].str.replace('.', '')
    df['Total'] = df['Total'].astype(float)
    df['Fecha de Emision '] = pd.to_datetime(df['Fecha de Emision '], format='%d/%m/%Y')
    df['Fecha de Vencimiento'] = pd.to_datetime(df['Fecha de Vencimiento'], format='%d/%m/%Y')
    df['Cuenta'] = df['Cuenta'].astype(int)
    df['IVA 27%'] = df['IVA 27%'].replace({True: 'Sí', False: 'No'})
    df['Perc IVA'] = df['Perc IVA'].replace({True: 'Sí', False: 'No'})


    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})[A-Za-z](\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)
        return "No encontrado", "No encontrado"

    #verificar el destinatario

    #separar el periodo
    def separar_periodo(periodo):
        try:
            Desde, Hasta = periodo.split(' al ')
            return pd.Series([Desde, Hasta], index=['Desde', 'Hasta'])
        except ValueError:
            return pd.Series([None, None], index=['Desde', 'Hasta'])


    # Aplicar la función y crear nuevas columnas
    df[['sucursal', 'factura']] = df['Numero de factura'].apply(separar_codigo).apply(pd.Series)
    df[['Desde', 'Hasta']] = df['Periodo'].apply(separar_periodo)
    df = df.drop(columns=['Periodo','Numero de factura'])
    df['Desde'] = pd.to_datetime(df['Desde'], format='%d/%m/%Y')
    df['Hasta'] = pd.to_datetime(df['Hasta'], format='%d/%m/%Y')
    df['sucursal'] = df['sucursal'].astype(int)
    df['factura'] = df['factura'].astype(int)

    nuevo_orden = ['sucursal', 'factura','Cuenta','Fecha de Emision ', 'Fecha de Vencimiento', 'Desde', 'Hasta', 'IVA 27%', 'Perc IVA', 'Total','Pagina', 'Destinatario','Domicilio']
    df = df[nuevo_orden]
    df.head()

    """ADICIONALES"""
    def encontrar_saltos(paginas):
        saltos = []
        for i in range(1, len(paginas)):
            diferencia = paginas[i] - paginas[i - 1]
            if diferencia > 2:
                saltos.append((paginas[i - 1], paginas[i]))
        return saltos

    # Ejemplo de uso
    paginas = df['Pagina'].tolist()
    saltos_encontrados = encontrar_saltos(paginas)
    print("Saltos encontrados entre las siguientes páginas:")
    for inicio, fin in saltos_encontrados:
        print(f"Entre {inicio} y {fin}")

    """EXPORTAR"""
    nombre = 'facturas leidas.xlsx'
    df.to_excel(nombre, index = False)
    files.download(nombre)

"""EDENOR"""

# @title
def edenor_simple():
    # simple
    ### CARGAR ARCHIVOS Y EXTRAER LOS DATOS ----------------------------------------
    # Subir múltiples archivos PDF
    archivos_subidos = files.upload()

    # Obtener los nombres de los archivos subidos
    nombres_archivos = list(archivos_subidos.keys())

    # Crear listas para almacenar nombres de archivos con 'T3' y sin 'T3'
    nombres_t3 = []     # Lista para almacenar nombres de archivos con 'T3'
    nombres_no_t3 = []  # Lista para almacenar nombres de archivos sin 'T3'
    # Iterar sobre los nombres de los archivos subidos
    for nombre in nombres_archivos:
        if 'T3' in nombre:
            nombres_t3.append(nombre)
        else:
            nombres_no_t3.append(nombre)


    # Función para leer el texto de un archivo PDF
    def leer_texto_pdf(file_path):
        #Lee el texto de un archivo PDF y devuelve una lista de textos, uno por cada página.

        #:param file_path: Ruta del archivo PDF.
        #:return: Lista de textos extraídos de cada página.

        textos_paginas = []
        with fitz.open(file_path) as doc:
            for pagina in doc:
                textos_paginas.append(pagina.get_text())
        return textos_paginas


    ### leer y extraer de las no T3 ###---------------------------------------------
    # Define patrones para extraer datos específicos
    patron_numero_factura = r'\b(\d{4}-\d{8})\b'
    patron_cuenta = r'Cuenta\s+(\d+(?:\s+\d+)*)'
    patron_emision = r'Emisión (\d{2}/\d{2}/\d{4})'
    patron_fecha_vencimiento = r'Hasta el (\d{2}/\d{2}/\d{4})'
    patron_total = r'TOTAL A PAGAR[:\s]*[\$]?\s*([\d.,]+(?:\s*\d{2})?)'
    patron_periodo = r'Período de consumo:\s*[:\-]?\s*(.*?)(?=\n\S|$)'

    # Lista para almacenar los datos de todas las facturas
    facturas_datos = []
    # Diccionario para almacenar el texto completo de cada PDF
    texto_pdfs = {}

    for nombre_archivo in nombres_no_t3:
        # Leer el texto del PDF
        paginas_texto = leer_texto_pdf(nombre_archivo)

        # Combinar el texto de todas las páginas para facilitar la búsqueda
        texto_completo = " ".join(paginas_texto)

        # Guardar el texto completo en el diccionario
        texto_pdfs[nombre_archivo] = texto_completo

        # Buscar los patrones en el texto extraído
        numero_factura = re.search(patron_numero_factura, texto_completo)
        cuenta = re.search(patron_cuenta, texto_completo)
        fecha_emision = re.search(patron_emision, texto_completo)
        fecha_vencimiento = re.search(patron_fecha_vencimiento, texto_completo)
        total = re.search(patron_total, texto_completo)
        periodo = re.search(patron_periodo, texto_completo)

        # Crear un diccionario con los datos extraídos
        datos_factura = {
            'Nombre Archivo': nombre_archivo,
            'Número de Factura': numero_factura.group(1) if numero_factura else "No encontrado",
            'Cuenta': cuenta.group(1) if cuenta else "No encontrado",
            'Emisión': fecha_emision.group(1) if fecha_emision else "No encontrado",
            'Fecha de Vencimiento': fecha_vencimiento.group(1) if fecha_vencimiento else "No encontrado",
            'Total': total.group(1) if total else "No encontrado",
            'Periodo': periodo.group(1) if periodo else "No encontrado"
        }

        # Agregar el diccionario a la lista
        facturas_datos.append(datos_factura)

    # Mostrar los textos completos (opcional)
    # for nombre_archivo, texto in texto_pdfs.items():
    #     print(f"Texto de {nombre_archivo}:\n{texto}\n")


    ### leer y extraer de facturas Tarifa T3###-------------------------------------
    # Define patrones para extraer datos específicos
    patron_numero_factura = r'\b(\d{4}-\d{8})\b'
    patron_cuenta = r'Cuenta N°\n(\d{1} \d{3} \d{3} \d{3})'
    patron_emision = r'Emisión:\s*(\d{2}/\d{2}/\d{4})'
    patron_fecha_vencimiento = r'Fecha de Vto.:\s*(\d{2}/\d{2}/\d{4})'
    patron_total = r'TOTAL CON IMPUESTOS:\n (\d{1}\.\d{3}\.\d{3},\d{2})'
    patron_fechas_lectura = r'Fechas de Lectura\s*\n\s*(\d{2}/\d{2}/\d{4})\s*\n\s*(\d{2}/\d{2}/\d{4})'

    # Lista para almacenar los datos de todas las facturas
    facturas_datos_t3 = [] # Cambiado a facturas_datos_t3
    # Diccionario para almacenar el texto completo de cada PDF
    texto_pdfs_t3 = {} # Cambiado a texto_pdfs_t3

    for nombre_archivo in nombres_t3:
        # Leer el texto del PDF
        paginas_texto = leer_texto_pdf(nombre_archivo)

        # Combinar el texto de todas las páginas para facilitar la búsqueda
        texto_completo = " ".join(paginas_texto)

        # Guardar el texto completo en el diccionario
        texto_pdfs_t3[nombre_archivo] = texto_completo # Cambiado a texto_pdfs_t3

        # Buscar los patrones en el texto extraído
        numero_factura = re.search(patron_numero_factura, texto_completo)
        cuenta = re.search(patron_cuenta, texto_completo)
        fecha_emision = re.search(patron_emision, texto_completo)
        fecha_vencimiento = re.search(patron_fecha_vencimiento, texto_completo)
        total = re.search(patron_total, texto_completo)
        fechas_lectura = re.search(patron_fechas_lectura, texto_completo)

        # Crear un diccionario con los datos extraídos
        datos_factura = {
            'Nombre Archivo': nombre_archivo,
            'Número de Factura': numero_factura.group(1) if numero_factura else "No encontrado",
            'Cuenta': cuenta.group(1) if cuenta else "No encontrado",
            'Emisión': fecha_emision.group(1) if fecha_emision else "No encontrado",
            'Fecha de Vencimiento': fecha_vencimiento.group(1) if fecha_vencimiento else "No encontrado",
            'Total': total.group(1) if total else "No encontrado",
            'Fechas de Lectura': (fechas_lectura.group(1) + ' - ' + fechas_lectura.group(2)) if fechas_lectura else "No encontrado"
        }

        # Agregar el diccionario a la lista
        facturas_datos_t3.append(datos_factura) # Cambiado a facturas_datos_t3


    ### CREAR EL DATAFRAME ###------------------------------------------------------
    #dataframe
    df_facturas_t3 = pd.DataFrame(facturas_datos_t3) # Cambiado a df_facturas_t3

    identificadores_t3 = df_facturas_t3['Número de Factura'] # Cambiado a identificadores_t3 and df_facturas_t3


    ### GENERAR EL ARCHIVO DATAFRAME ### -------------------------------------------
    # Convertir la lista de diccionarios en un DataFrame
    df_facturas = pd.DataFrame(facturas_datos)

    identificadores= df_facturas['Número de Factura']
    #separar el numero de factura
    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})-(\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)
        return "No encontrado", "No encontrado"


    df_facturas[['sucursal', 'factura']] = df_facturas['Número de Factura'].apply(separar_codigo).apply(pd.Series)
    df_facturas = df_facturas.drop(columns=['Número de Factura'])
    df_facturas['sucursal'] = pd.to_numeric(df_facturas['sucursal'], errors='coerce')
    df_facturas['factura'] = pd.to_numeric(df_facturas['factura'], errors='coerce')

    #separar el periodo
    def separar_periodo(periodo):
        try:
            Desde, Hasta = periodo.split(' AL ')
            return pd.Series([Desde, Hasta], index=['Desde', 'Hasta'])
        except ValueError:
            return pd.Series([None, None], index=['Desde', 'Hasta'])

    def verificar_texto_en_facturas(textos_pdfs, identificadores, texto_a_buscar):
        resultados = {identificador: 'Factura no encontrada' for identificador in identificadores}

        # Itera sobre cada fragmento de texto (identificador) en la lista de identificadores
        for identificador in identificadores:
            for clave, texto_pdf in textos_pdfs.items():
                # Verifica si el fragmento de texto (identificador) está en el texto del PDF
                if identificador in texto_pdf:
                    # Verifica si el texto_a_buscar está en el texto del PDF
                    if texto_a_buscar in texto_pdf:
                        resultados[identificador] = 'si'
                    else:
                        resultados[identificador] = 'no'
                    break  # Detiene la búsqueda una vez encontrado el identificador en algún texto

        return resultados


    def verificar_texto_en_facturas(textos_pdfs, identificadores, texto_a_buscar):
        resultados = {}

        for clave, texto_pdf in textos_pdfs.items():
            # Verificar si alguno de los identificadores está en el texto del PDF
            for identificador in identificadores:
                if identificador in texto_pdf:
                    # Verificar si el texto_a_buscar está en el texto del PDF
                    if texto_a_buscar in texto_pdf:
                        resultados[clave] = 'si'
                    else:
                        resultados[clave] = 'no'
                    break  # Solo necesitas encontrar un identificador para considerar el PDF

        return resultados


    # Aplicar la función al DataFrame
    df_facturas[['Desde', 'Hasta']] = df_facturas['Periodo'].apply(separar_periodo)
    df_facturas = df_facturas.drop(columns=['Periodo'])

    #dar formato a los numeros
    df_facturas['Fecha de Vencimiento'] = pd.to_datetime(df_facturas['Fecha de Vencimiento'], format='%d/%m/%Y')
    df_facturas['Desde'] = pd.to_datetime(df_facturas['Desde'], format='%d/%m/%Y')
    df_facturas['Hasta'] = pd.to_datetime(df_facturas['Hasta'], format='%d/%m/%Y')
    df_facturas['Emisión'] = pd.to_datetime(df_facturas['Emisión'], format='%d/%m/%Y')

    def convertir_a_flotante(numero_str):
        try:
            # Reemplazar el punto de miles y la coma decimal
            numero_str = numero_str.replace('.', '').replace(',', '.')
            # Convertir a flotante
            return float(numero_str)
        except ValueError:
            # Manejar posibles errores de conversión
            return None

    # Aplicar la función a toda la columna 'Monto'
    df_facturas['Total'] = df_facturas['Total'].apply(convertir_a_flotante)

    lista_nuevo_orden=['sucursal','factura','Cuenta','Emisión','Fecha de Vencimiento','Desde','Hasta','Total', 'Nombre Archivo']
    df_facturas=df_facturas[lista_nuevo_orden]

    resultados = verificar_texto_en_facturas(texto_pdfs, identificadores, 'GOBIERNO CIUDAD AUTÓNOMA')
    df_facturas['destinatario: GOBIERNO CIUDAD AUTÓNOMA']= resultados.values()
    df_1=df_facturas


    ### leer y extraer de facturas Tarifa T3 ###------------------------------------
    # Define patrones para extraer datos específicos
    patron_numero_factura = r'\b(\d{4}-\d{8})\b'
    patron_cuenta = r'Cuenta N°\n(\d{1} \d{3} \d{3} \d{3})'
    patron_emision = r'Emisión:\s*(\d{2}/\d{2}/\d{4})'
    patron_fecha_vencimiento = r'Fecha de Vto.:\s*(\d{2}/\d{2}/\d{4})'
    patron_total = r'TOTAL CON IMPUESTOS:\n (\d{1}\.\d{3}\.\d{3},\d{2})'
    patron_fechas_lectura = r'Fechas de Lectura\s*\n\s*(\d{2}/\d{2}/\d{4})\s*\n\s*(\d{2}/\d{2}/\d{4})'

    # Lista para almacenar los datos de todas las facturas
    facturas_datos = []
    # Diccionario para almacenar el texto completo de cada PDF
    texto_pdfs = {}

    for nombre_archivo in nombres_t3:
        # Leer el texto del PDF
        paginas_texto = leer_texto_pdf(nombre_archivo)

        # Combinar el texto de todas las páginas para facilitar la búsqueda
        texto_completo = " ".join(paginas_texto)

        # Guardar el texto completo en el diccionario
        texto_pdfs[nombre_archivo] = texto_completo

        # Buscar los patrones en el texto extraído
        numero_factura = re.search(patron_numero_factura, texto_completo)
        cuenta = re.search(patron_cuenta, texto_completo)
        fecha_emision = re.search(patron_emision, texto_completo)
        fecha_vencimiento = re.search(patron_fecha_vencimiento, texto_completo)
        total = re.search(patron_total, texto_completo)
        fechas_lectura = re.search(patron_fechas_lectura, texto_completo)

        # Crear un diccionario con los datos extraídos
        datos_factura = {
            'Nombre Archivo': nombre_archivo,
            'Número de Factura': numero_factura.group(1) if numero_factura else "No encontrado",
            'Cuenta': cuenta.group(1) if cuenta else "No encontrado",
            'Emisión': fecha_emision.group(1) if fecha_emision else "No encontrado",
            'Fecha de Vencimiento': fecha_vencimiento.group(1) if fecha_vencimiento else "No encontrado",
            'Total': total.group(1) if total else "No encontrado",
            'Fechas de Lectura': (fechas_lectura.group(1) + ' - ' + fechas_lectura.group(2)) if fechas_lectura else "No encontrado"
        }

        # Agregar el diccionario a la lista
        facturas_datos.append(datos_factura)

    ###CREAR EL DATAFRAME###-------------------------------------------------------
    #dataframe
    df_facturas = pd.DataFrame(facturas_datos)

    identificadores = df_facturas['Número de Factura']
    #separar el numero de factura
    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})-(\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)
        return "No encontrado", "No encontrado"


    df_facturas[['sucursal', 'factura']] = df_facturas['Número de Factura'].apply(separar_codigo).apply(pd.Series)
    df_facturas = df_facturas.drop(columns=['Número de Factura'])
    df_facturas['sucursal'] = pd.to_numeric(df_facturas['sucursal'], errors='coerce')
    df_facturas['factura'] = pd.to_numeric(df_facturas['factura'], errors='coerce')

    #separar el periodo
    def separar_periodo(fecha_lectura):
        try:
            desde, hasta = fecha_lectura.split(' - ')
            return pd.Series([desde.strip(), hasta.strip()], index=['Desde', 'Hasta'])
        except ValueError:
            return pd.Series([None, None], index=['Desde', 'Hasta'])

    def verificar_texto_en_facturas(textos_pdfs, identificadores, texto_a_buscar):
        resultados = {identificador: 'Factura no encontrada' for identificador in identificadores}

        # Itera sobre cada fragmento de texto (identificador) en la lista de identificadores
        for identificador in identificadores:
            for clave, texto_pdf in textos_pdfs.items():
                # Verifica si el fragmento de texto (identificador) está en el texto del PDF
                if identificador in texto_pdf:
                    # Verifica si el texto_a_buscar está en el texto del PDF
                    if texto_a_buscar in texto_pdf:
                        resultados[identificador] = 'si'
                    else:
                        resultados[identificador] = 'no'
                    break  # Detiene la búsqueda una vez encontrado el identificador en algún texto

        return resultados


    def verificar_texto_en_facturas(textos_pdfs, identificadores, texto_a_buscar):
        resultados = {}

        for clave, texto_pdf in textos_pdfs.items():
            # Verificar si alguno de los identificadores está en el texto del PDF
            for identificador in identificadores:
                if identificador in texto_pdf:
                    # Verificar si el texto_a_buscar está en el texto del PDF
                    if texto_a_buscar in texto_pdf:
                        resultados[clave] = 'si'
                    else:
                        resultados[clave] = 'no'
                    break  # Solo necesitas encontrar un identificador para considerar el PDF

        return resultados


    # Aplicar la función al DataFrame
    fechas_lectura = df_facturas['Fechas de Lectura'].apply(separar_periodo)

    ## Concatenar el DataFrame original con el DataFrame resultante de 'separar_periodo'
    df_facturas = pd.concat([df_facturas, fechas_lectura], axis=1)

    # Eliminar la columna original 'Fecha de Lectura'
    df_facturas.drop(columns=['Fechas de Lectura'], inplace=True)

    #dar formato a los numeros
    df_facturas['Fecha de Vencimiento'] = pd.to_datetime(df_facturas['Fecha de Vencimiento'], format='%d/%m/%Y')
    df_facturas['Desde'] = pd.to_datetime(df_facturas['Desde'], format='%d/%m/%Y')
    df_facturas['Hasta'] = pd.to_datetime(df_facturas['Hasta'], format='%d/%m/%Y')
    df_facturas['Emisión'] = pd.to_datetime(df_facturas['Emisión'], format='%d/%m/%Y')

    def convertir_a_flotante(numero_str):
        try:
            # Reemplazar el punto de miles y la coma decimal
            numero_str = numero_str.replace('.', '').replace(',', '.')
            # Convertir a flotante
            return float(numero_str)
        except ValueError:
            # Manejar posibles errores de conversión
            return None

    # Aplicar la función a toda la columna 'Monto'
    df_facturas['Total'] = df_facturas['Total'].apply(convertir_a_flotante)

    lista_nuevo_orden=['sucursal','factura','Cuenta','Emisión','Fecha de Vencimiento','Desde','Hasta','Total', 'Nombre Archivo']
    df_facturas=df_facturas[lista_nuevo_orden]

    resultados = verificar_texto_en_facturas(texto_pdfs, identificadores, 'GOBIERNO CIUDAD AUTÓNOMA')
    df_facturas['destinatario: GOBIERNO CIUDAD AUTÓNOMA']= resultados.values()
    df_2=df_facturas

    df_facturas= pd.concat([df_1,df_2], axis=0)

    ### EXPORTAR EL ARCHIVO DE EXCEL ###--------------------------------------------
    nombre_archivo = 'EDENOR facturas leidas.xlsx'
    df_facturas.to_excel(nombre_archivo, index=False)
    files.download(nombre_archivo)
    print('-------------')
    print('Archivo generado y descargado exitosamente')

"""EDESUR"""

def edesur_t1_simple():
    # @title
    edesur_t1_regiones= [(210,3,670,50),(210,135,390,170),(30,300,190,340),(280,300,570,540)]

    """Cargar el archivo"""
    uploaded = files.upload()
    file_path = next(iter(uploaded.keys()))

    """ crear el df con las regiones"""
    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def procesar_varios_pdfs(lista_pdfs, regiones, pagina_numero=1):
        """
        Procesa varios archivos PDF y extrae las regiones definidas.

        Args:
        - lista_pdfs (list): Lista de rutas a los archivos PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).
        - pagina_numero (int): Número de la página a analizar (por defecto 1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada PDF.
        """
        # Lista para almacenar los datos de cada PDF
        datos_pdf = []

        # Iterar sobre cada archivo PDF
        for pdf_path in lista_pdfs:
            # Extraer texto de las regiones
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_pdf.append({
                "Archivo": pdf_path,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_pdf)

        return df

    # Ejemplo de uso con varios archivos PDF

    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF

    regiones = edesur_t1_regiones  # Coordenadas de

    # Extraer texto de las regiones
    df = procesar_varios_pdfs(lista_pdfs ,regiones , 1)
    #df.head()

    """extraer datos"""
    #REGION 1
    def extraer_lsp(texto):
        # Busca el número de LSP en el formato esperado
        lsp = re.search(r'Liquidación de Servicios Públicos \(LSP\) B (\d{4}-\d{8}) \d+', texto)
        return lsp.group(1) if lsp else "No encontrado"

    def extraer_cliente(texto):
        # Busca el número de cliente
        cliente = re.search(r'Cliente:\s*(\d+)', texto)
        return cliente.group(1) if cliente else "No encontrado"

    def extraer_medidor(texto):
        # Busca el número de medidor
        medidor = re.search(r'N° de medidor:\s*(\d+)', texto)
        return medidor.group(1) if medidor else "No encontrado"

    def extraer_destinatario(texto):
        # Elimina líneas que contienen las palabras específicas
        lineas_relevantes = [
            linea for linea in texto.splitlines()
            if not re.search(r'Liquidación|Cliente|N° de medidor|Hoja', linea)
        ]

        # Filtrar las líneas restantes y devolver la primera que no esté vacía
        for linea in lineas_relevantes:
            if linea.strip():  # Ignora líneas vacías
                return linea.strip()

        return "No encontrado"

    #region 2
    def extraer_vencimiento(texto):
        # Busca la fecha de vencimiento en el formato dd/mm/yyyy
        vencimiento = re.search(r'1° Vencimiento:\s*(\d{2}/\d{2}/\d{4})', texto)
        return vencimiento.group(1) if vencimiento else "No encontrado"

    def extraer_total(texto):
        # Busca el total en formato numérico con el símbolo de $
        total = re.search(r'TOTAL:\s*\$\s*([\d.,]+)', texto)
        return total.group(1) if total else "No encontrado"

    #REGion 3
    def extraer_estado_actual(texto):
        # Busca el estado actual en el formato "Estado actual al dd/mm/yyyy"
        estado_actual = re.search(r'Estado actual al\s*(\d{2}/\d{2}/\d{4})', texto)
        return estado_actual.group(1) if estado_actual else "No encontrado"

    def extraer_estado_anterior(texto):
        # Busca el estado anterior en el formato "Estado anterior al dd/mm/yyyy"
        estado_anterior = re.search(r'Estado anterior al\s*(\d{2}/\d{2}/\d{4})', texto)
        return estado_anterior.group(1) if estado_anterior else "No encontrado"

    #region 4
    def extraer_saldo_anterior(texto):
        saldo_patron = r'Saldo anterior\s*([\d.,]+[-]?)'
        saldo_match = re.search(saldo_patron, texto)

        saldo_anterior = saldo_match.group(1).replace(',', '') if saldo_match else 'No encontrado'
        if saldo_anterior.endswith('-'):
            saldo_anterior = '-' + saldo_anterior[:-1]  # Coloca el signo menos al principio

        return saldo_anterior

    def extraer_bonificacion(texto):
        bonificacion_patron = r'Bonificacion\s*([\d.,]+)'
        bonificacion_match = re.search(bonificacion_patron, texto)

        bonificacion = bonificacion_match.group(1).replace(',', '') if bonificacion_match else 'No encontrado'

        return bonificacion

    def extraer_interes_mora(texto):
        interes_mora_patron = r'Interés\s*mora\s*[:\-]?\s*([\d.,]+[-]?)'
        interes_mora_match = re.search(interes_mora_patron, texto)

        interes_mora = interes_mora_match.group(1).replace(',', '') if interes_mora_match else 'No encontrado'
        if interes_mora.endswith('-'):
            interes_mora = '-' + interes_mora[:-1]  # Coloca el signo menos al principio

        return interes_mora

    df['numero de factura'] = df['Region_1'].apply(extraer_lsp)
    df['Cliente'] = df['Region_1'].apply(extraer_cliente)
    df['Medidor'] = df['Region_1'].apply(extraer_medidor)
    df['Destinatario'] = df['Region_1'].apply(extraer_destinatario)
    df['Vencimiento'] = df['Region_2'].apply(extraer_vencimiento)
    df['Total'] = df['Region_2'].apply(extraer_total)
    df['Hasta'] = df['Region_3'].apply(extraer_estado_actual)
    df['Desde'] = df['Region_3'].apply(extraer_estado_anterior)
    df['Saldo Anterior'] = df['Region_4'].apply(extraer_saldo_anterior)
    df['Bonificaciones'] = df['Region_4'].apply(extraer_bonificacion)
    df['Interés Mora'] = df['Region_4'].apply(extraer_interes_mora)
    #df.head()

    """ Ajustar las columnas"""
    df.drop(columns=['Region_1', 'Region_2', 'Region_3', 'Region_4'], inplace=True)
    df['Cliente'] = pd.to_numeric(df['Cliente'], errors='coerce')
    df['Medidor'] = pd.to_numeric(df['Medidor'], errors='coerce')
    df['Total'] = df['Total'].str.replace(',', '').astype(float)
    df['Desde'] = pd.to_datetime(df['Desde'], format='%d/%m/%Y')
    df['Hasta'] = pd.to_datetime(df['Hasta'], format='%d/%m/%Y')
    df['Vencimiento'] = pd.to_datetime(df['Vencimiento'], format='%d/%m/%Y')


    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})-(\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)
        return "No encontrado", "No encontrado"

    # Aplicar la función y crear nuevas columnas
    df[['sucursal', 'factura']] = df['numero de factura'].apply(separar_codigo).apply(pd.Series)
    df = df.drop(columns=['numero de factura'])
    df['sucursal'] = pd.to_numeric(df['sucursal'], errors='coerce')
    df['factura'] = pd.to_numeric(df['factura'], errors='coerce')

    df.replace('No encontrado', 0, inplace=True)
    df['Saldo Anterior'] = df['Saldo Anterior'].astype(float)
    df['Bonificaciones'] = df['Bonificaciones'].astype(float)
    df['Interés Mora'] = df['Interés Mora'].astype(float)

    lista_nuevo_orden=['sucursal','factura','Cliente','Medidor','Vencimiento','Desde','Hasta','Saldo Anterior','Bonificaciones','Interés Mora','Total','Destinatario','Archivo']
    df = df[lista_nuevo_orden]
    df.head()

    """exportar el df a excel"""
    nombre = 'edesur T1 facturas leidas.xlsx'
    df.to_excel(nombre, index=False)
    files.download(nombre)

def edesur_t2_simple():
    # @title
    ### tarifa 2y3  simple
    edesur_t2y3_regiones = [(225,23,500,70),(225,150,570,180),(30,370,80,410,),(180,360,270,410),(30,425,570,495),(30,70,150,120)]
    """cargar el archivo"""
    uploaded = files.upload()

    """extraer texto"""
    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def procesar_varios_pdfs(lista_pdfs, regiones, pagina_numero=1):
        """
        Procesa varios archivos PDF y extrae las regiones definidas.

        Args:
        - lista_pdfs (list): Lista de rutas a los archivos PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).
        - pagina_numero (int): Número de la página a analizar (por defecto 1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada PDF.
        """
        # Lista para almacenar los datos de cada PDF
        datos_pdf = []

        # Iterar sobre cada archivo PDF
        for pdf_path in lista_pdfs:
            # Extraer texto de las regiones
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_pdf.append({
                "Archivo": pdf_path,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_pdf)

        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF
    regiones = edesur_t2y3_regiones  # Coordenadas de

    # Extraer texto de las regiones
    df = procesar_varios_pdfs(lista_pdfs ,regiones , 1)

    # Mostrar el texto extraído de cada región
    #df.head()

    """EXTRAER DATOS DE LAS REGIONES"""
    #REGION 1
    def extraer_lsp(texto):
        # Busca el número de LSP en el formato esperado
        lsp = re.search(r'Liquidación de Servicios Públicos \(LSP\) B (\d{4}-\d{8}) \d+', texto)
        return lsp.group(1) if lsp else "No encontrado"

    def extraer_cliente(texto):
        # Busca el número de cliente
        cliente = re.search(r'Su número de cliente es\s*(\d+)', texto)
        return cliente.group(1) if cliente else "No encontrado"


    def extraer_destinatario(texto):
        # Elimina líneas que contienen las palabras específicas
        lineas_relevantes = [
            linea for linea in texto.splitlines()
            if not re.search(r'Liquidación|Cliente|N° de medidor|Hoja', linea)
        ]

        # Filtrar las líneas restantes y devolver la primera que no esté vacía
        for linea in lineas_relevantes:
            if linea.strip():  # Ignora líneas vacías
                return linea.strip()

        return "No encontrado"

    #region 2
    def extraer_vencimiento(texto):
        # Busca la fecha de vencimiento en el formato dd/mm/yyyy
        vencimiento = re.search(r'Esta liquidación vence el\s*(\d{2}/\d{2}/\d{4})', texto)
        return vencimiento.group(1) if vencimiento else "No encontrado"


    def extraer_total(texto):
        # Expresión regular para encontrar el total
        patron_total = r'\b(\d{1,3}(?:,\d{3})*\.\d{2})\b'
        total_match = re.findall(patron_total, texto)

        # Obtener el total si se encontró
        total = total_match[-1] if total_match else 'No encontrado'  # Obtenemos el último total si hay varios
        return total.strip()

    #region 3
    def extraer_medidor(texto):
        # Busca el número de medidor
        medidor = re.search(r'Nro Medidor\s*(\d+)', texto)
        return medidor.group(1) if medidor else "No encontrado"

    #region 4
    def extraer_fechas(texto):
        # Patrón para buscar fechas en formato dd/mm/aaaa
        patron_fecha = r'\b(\d{2}/\d{2}/\d{4})\b'

        # Buscar todas las fechas en el texto
        fechas = re.findall(patron_fecha, texto)

        # Si se encuentran al menos dos fechas, devolverlas como "Desde" y "Hasta"
        if len(fechas) >= 2:
            return pd.Series([fechas[0], fechas[1]])
        else:
            return pd.Series([None, None])  # Si no se encuentran suficientes fechas, devolver None

    #region 5
    def extraer_saldo_anterior(texto):
        # Buscar el saldo anterior
        saldo_patron = r'Saldo anterior\s*([\d,.]+)'
        saldo_match = re.search(saldo_patron, texto)
        saldo_anterior = saldo_match.group(1) if saldo_match else 'No encontrado'
        return saldo_anterior

    def extraer_bonificacion(texto):
        # Buscar la bonificación
        bonificacion_patron = r'Bonif_Interrupciones_Sem_\d+\s*([\d,.]+-)'
        bonificacion_match = re.search(bonificacion_patron, texto)
        bonificacion = bonificacion_match.group(1).replace('-', '') if bonificacion_match else 'No encontrado'
        return '-' + bonificacion if bonificacion != 'No encontrado' else bonificacion

    def extraer_interes_mora(texto):
        # Buscar el interés mora
        interes_mora_patron = r'Interés Mora\s*([\d,.]+)'
        interes_mora_match = re.search(interes_mora_patron, texto)
        interes_mora = interes_mora_match.group(1) if interes_mora_match else 'No encontrado'
        return interes_mora

    #region 6
    def extraer_fecha(texto):
        patron_fecha = r'\b(\d{2}/\d{2}/\d{4})\b'
        fecha_match = re.search(patron_fecha, texto)
        return fecha_match.group(1) if fecha_match else 'Fecha no encontrada'


    df['numero de factura'] = df['Region_1'].apply(extraer_lsp)
    df['Cliente'] = df['Region_1'].apply(extraer_cliente)
    df['Destinatario'] = df['Region_1'].apply(extraer_destinatario)
    df['Vencimiento'] = df['Region_2'].apply(extraer_vencimiento)
    df['Total'] = df['Region_2'].apply(extraer_total)
    df['Medidor'] = df['Region_3'].apply(extraer_medidor)
    df[['Desde', 'Hasta']] = df['Region_4'].apply(extraer_fechas)
    df['Saldo Anterior'] = df['Region_5'].apply(extraer_saldo_anterior)
    df['Bonificaciones'] = df['Region_5'].apply(extraer_bonificacion)
    df['Interés Mora'] = df['Region_5'].apply(extraer_interes_mora)
    df['Emision'] = df['Region_6'].apply(extraer_fecha)
    #df.head()

    """ Ajustar las columnas"""
    df.drop(columns=['Region_1', 'Region_2', 'Region_3', 'Region_4'], inplace=True)
    df['Cliente'] = pd.to_numeric(df['Cliente'], errors='coerce')
    df['Medidor'] = pd.to_numeric(df['Medidor'], errors='coerce')
    df['Total'] = df['Total'].str.replace(',', '').astype(float)
    df['Desde'] = pd.to_datetime(df['Desde'], format='%d/%m/%Y')
    df['Hasta'] = pd.to_datetime(df['Hasta'], format='%d/%m/%Y')
    df['Vencimiento'] = pd.to_datetime(df['Vencimiento'], format='%d/%m/%Y')
    df['Saldo Anterior'] = df['Saldo Anterior'].str.replace(',', '')
    df['Bonificaciones'] = df['Bonificaciones'].str.replace(',', '')
    df['Interés Mora'] = df['Interés Mora'].str.replace(',', '')
    df['Emision'] = pd.to_datetime(df['Emision'], format='%d/%m/%Y')

    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})-(\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)
        return "No encontrado", "No encontrado"

    # Aplicar la función y crear nuevas columnas
    df[['sucursal', 'factura']] = df['numero de factura'].apply(separar_codigo).apply(pd.Series)
    df = df.drop(columns=['numero de factura'])
    df['sucursal'] = pd.to_numeric(df['sucursal'], errors='coerce')
    df['factura'] = pd.to_numeric(df['factura'], errors='coerce')

    df.replace('No encontrado', 0, inplace=True)
    df['Saldo Anterior'] = df['Saldo Anterior'].astype(float)
    df['Bonificaciones'] = df['Bonificaciones'].astype(float)
    df['Interés Mora'] = df['Interés Mora'].astype(float)

    lista_nuevo_orden=['sucursal','factura','Cliente','Medidor','Emision','Vencimiento','Desde','Hasta','Saldo Anterior','Bonificaciones','Interés Mora','Total','Destinatario','Archivo']
    df = df[lista_nuevo_orden]
    df.head()

    """EXPORTAR"""
    nombre = 'EDESUR tarifa 2y3 facturas leidas.xlsx'
    df.to_excel(nombre, index=False)
    files.download(nombre)

def edesur_t1_unificado():
    # @title
    edesur_t1_regiones= [(210,3,670,50),(210,135,390,170),(30,300,190,340),(280,300,570,540)]

    """cargar el archivo"""
    uploaded = files.upload()

    """"extraer regiones y crear el df"""
    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def obtener_numero_paginas(pdf_path):
        """
        Obtiene el número total de páginas en un archivo PDF.

        Args:
        - pdf_path (str): Ruta al archivo PDF.

        Returns:
        - int: Número total de páginas en el PDF.
        """
        with fitz.open(pdf_path) as pdf:
            num_paginas = pdf.page_count
        return num_paginas


    def procesar_pdf_con_varias_paginas(pdf_path, regiones):
        """
        Procesa un archivo PDF con múltiples páginas y extrae las regiones definidas.

        Args:
        - pdf_path (str): Ruta al archivo PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada página del PDF.
        """
        # Lista para almacenar los datos de cada página del PDF
        datos_paginas = []

        # Obtener el número total de páginas del PDF
        num_paginas = obtener_numero_paginas(pdf_path)
        print(num_paginas)
        # Iterar sobre cada página del PDF
        for pagina_numero in range(1, num_paginas + 1):
            # Extraer texto de las regiones en la página actual
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_paginas.append({
                "Archivo": pdf_path,
                "Pagina": pagina_numero,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_paginas)

        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF
    file_path = next(iter(uploaded.keys()))
    regiones = edesur_t1_regiones  # Coordenadas de
    # Extraer texto de las regiones
    df = procesar_pdf_con_varias_paginas(file_path ,regiones )

    """filtrar el texto"""
    #########detectar notas de credito/debito####
    def detectar_nota_credito_debito(texto):
        # Definir el patrón para detectar "nota de crédito" o "nota de débito"
        patron = r"Nota de (Crédito|Débito)"

        # Si el patrón se encuentra en el texto, retornar True
        return bool(re.search(patron, texto, re.IGNORECASE))

    paginas_con_nota = df[df['Region_1'].apply(detectar_nota_credito_debito)]['Pagina'].tolist()
    #eliminar paginas secundarias
    df = df[df['Region_1'].str.contains("Liquidación de Servicios", na=False, case=False)]

    # Mostrar el texto extraído de cada región
    #df.head(10)

    """extraer datos"""
    #REGION 1
    def extraer_lsp(texto):
        # Busca el número de LSP en el formato esperado
        lsp = re.search(r'Liquidación de Servicios Públicos \(LSP\) B (\d{4}-\d{8}) \d+', texto)
        return lsp.group(1) if lsp else "No encontrado"

    def extraer_cliente(texto):
        # Busca el número de cliente
        cliente = re.search(r'Cliente:\s*(\d+)', texto)
        return cliente.group(1) if cliente else "No encontrado"

    def extraer_medidor(texto):
        # Busca el número de medidor
        medidor = re.search(r'N° de medidor:\s*(\d+)', texto)
        return medidor.group(1) if medidor else "No encontrado"

    def extraer_destinatario(texto):
        # Elimina líneas que contienen las palabras específicas
        lineas_relevantes = [
            linea for linea in texto.splitlines()
            if not re.search(r'Liquidación|Cliente|N° de medidor|Hoja', linea)
        ]

        # Filtrar las líneas restantes y devolver la primera que no esté vacía
        for linea in lineas_relevantes:
            if linea.strip():  # Ignora líneas vacías
                return linea.strip()

        return "No encontrado"

    #region 2
    def extraer_vencimiento(texto):
        # Busca la fecha de vencimiento en el formato dd/mm/yyyy
        vencimiento = re.search(r'1° Vencimiento:\s*(\d{2}/\d{2}/\d{4})', texto)
        return vencimiento.group(1) if vencimiento else "No encontrado"

    def extraer_total(texto):
        # Busca el total en formato numérico con el símbolo de $
        total = re.search(r'TOTAL:\s*\$\s*([\d.,]+)', texto)
        return total.group(1) if total else "No encontrado"

    #REGion 3
    def extraer_estado_actual(texto):
        # Busca el estado actual en el formato "Estado actual al dd/mm/yyyy"
        estado_actual = re.search(r'Estado actual al\s*(\d{2}/\d{2}/\d{4})', texto)
        return estado_actual.group(1) if estado_actual else "No encontrado"

    def extraer_estado_anterior(texto):
        # Busca el estado anterior en el formato "Estado anterior al dd/mm/yyyy"
        estado_anterior = re.search(r'Estado anterior al\s*(\d{2}/\d{2}/\d{4})', texto)
        return estado_anterior.group(1) if estado_anterior else "No encontrado"

    #region 4
    def extraer_saldo_anterior(texto):
        saldo_patron = r'Saldo anterior\s*([\d.,]+[-]?)'
        saldo_match = re.search(saldo_patron, texto)

        saldo_anterior = saldo_match.group(1).replace(',', '') if saldo_match else 'No encontrado'
        if saldo_anterior.endswith('-'):
            saldo_anterior = '-' + saldo_anterior[:-1]  # Coloca el signo menos al principio

        return saldo_anterior

    def extraer_bonificacion(texto):
        bonificacion_patron = r'Bonificacion\s*([\d.,]+)'
        bonificacion_match = re.search(bonificacion_patron, texto)

        bonificacion = bonificacion_match.group(1).replace(',', '') if bonificacion_match else 'No encontrado'

        return bonificacion

    def extraer_interes_mora(texto):
        interes_mora_patron = r'Interés\s*mora\s*[:\-]?\s*([\d.,]+[-]?)'
        interes_mora_match = re.search(interes_mora_patron, texto)

        interes_mora = interes_mora_match.group(1).replace(',', '') if interes_mora_match else 'No encontrado'
        if interes_mora.endswith('-'):
            interes_mora = '-' + interes_mora[:-1]  # Coloca el signo menos al principio

        return interes_mora

    df['numero de factura'] = df['Region_1'].apply(extraer_lsp)
    df['Cliente'] = df['Region_1'].apply(extraer_cliente)
    df['Medidor'] = df['Region_1'].apply(extraer_medidor)
    df['Destinatario'] = df['Region_1'].apply(extraer_destinatario)
    df['Vencimiento'] = df['Region_2'].apply(extraer_vencimiento)
    df['Total'] = df['Region_2'].apply(extraer_total)
    df['Hasta'] = df['Region_3'].apply(extraer_estado_actual)
    df['Desde'] = df['Region_3'].apply(extraer_estado_anterior)
    df['Saldo Anterior'] = df['Region_4'].apply(extraer_saldo_anterior)
    df['Bonificaciones'] = df['Region_4'].apply(extraer_bonificacion)
    df['Interés Mora'] = df['Region_4'].apply(extraer_interes_mora)
    #df.head()
    """ Ajustar las columnas"""
    df.drop(columns=['Region_1', 'Region_2', 'Region_3', 'Region_4'], inplace=True)
    df['Cliente'] = pd.to_numeric(df['Cliente'], errors='coerce')
    df['Medidor'] = pd.to_numeric(df['Medidor'], errors='coerce')
    df['Total'] = df['Total'].str.replace(',', '').astype(float)
    df['Desde'] = pd.to_datetime(df['Desde'], format='%d/%m/%Y')
    df['Hasta'] = pd.to_datetime(df['Hasta'], format='%d/%m/%Y')
    df['Vencimiento'] = pd.to_datetime(df['Vencimiento'], format='%d/%m/%Y')


    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})-(\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)
        return "No encontrado", "No encontrado"

    # Aplicar la función y crear nuevas columnas
    df[['sucursal', 'factura']] = df['numero de factura'].apply(separar_codigo).apply(pd.Series)
    df = df.drop(columns=['numero de factura'])
    df['sucursal'] = pd.to_numeric(df['sucursal'], errors='coerce')
    df['factura'] = pd.to_numeric(df['factura'], errors='coerce')

    df.replace('No encontrado', 0, inplace=True)
    df['Saldo Anterior'] = df['Saldo Anterior'].astype(float)
    df['Bonificaciones'] = df['Bonificaciones'].astype(float)
    df['Interés Mora'] = df['Interés Mora'].astype(float)

    lista_nuevo_orden=['sucursal','factura','Cliente','Medidor','Vencimiento','Desde','Hasta','Saldo Anterior','Bonificaciones','Interés Mora','Total','Destinatario','Pagina']
    df = df[lista_nuevo_orden]

    """ADICIONALES"""
    def encontrar_saltos(paginas):
        saltos = []
        for i in range(1, len(paginas)):
            diferencia = paginas[i] - paginas[i - 1]
            if diferencia > 2:
                saltos.append((paginas[i - 1], paginas[i]))
        return saltos


    paginas = df['Pagina'].tolist()
    saltos_encontrados = encontrar_saltos(paginas)
    print("Saltos encontrados entre las siguientes páginas:")
    for inicio, fin in saltos_encontrados:
        print(f"Entre {inicio} y {fin}")
    print('Cantidad de saltos:', len(saltos_encontrados))
    #notas de debito/credito
    print(f"Páginas con 'nota de crédito/débito': {paginas_con_nota}")
    print('Notas encontradas en total:', len(paginas_con_nota))

    """exportar el df a excel"""
    nombre = 'edesur T1 facturas leidas.xlsx'
    df.to_excel(nombre, index=False)
    files.download(nombre)

def edesur_t2_unificado():
    # @title
    ### tarifa 2y3  unificado
    edesur_t2y3_regiones = [(225,23,500,70),(225,150,570,180),(30,370,80,410,),(180,360,270,410),(30,425,570,495),(30,70,150,120)]

    """cargar el archivo"""
    uploaded = files.upload()

    """extraer texto"""
    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def obtener_numero_paginas(pdf_path):
        """
        Obtiene el número total de páginas en un archivo PDF.

        Args:
        - pdf_path (str): Ruta al archivo PDF.

        Returns:
        - int: Número total de páginas en el PDF.
        """
        with fitz.open(pdf_path) as pdf:
            num_paginas = pdf.page_count
        return num_paginas


    def procesar_pdf_con_varias_paginas(pdf_path, regiones):
        """
        Procesa un archivo PDF con múltiples páginas y extrae las regiones definidas.

        Args:
        - pdf_path (str): Ruta al archivo PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada página del PDF.
        """
        # Lista para almacenar los datos de cada página del PDF
        datos_paginas = []

        # Obtener el número total de páginas del PDF
        num_paginas = obtener_numero_paginas(pdf_path)
        print(num_paginas)
        # Iterar sobre cada página del PDF
        for pagina_numero in range(1, num_paginas + 1):
            # Extraer texto de las regiones en la página actual
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_paginas.append({
                "Archivo": pdf_path,
                "Pagina": pagina_numero,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_paginas)

        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF

    file_path = next(iter(uploaded.keys()))

    regiones = edesur_t2y3_regiones  # Coordenadas de

    # Extraer texto de las regiones
    df = procesar_pdf_con_varias_paginas(file_path ,regiones )
    #notas
    def detectar_nota_credito_debito(texto):
        # Definir el patrón para detectar "nota de crédito" o "nota de débito"
        patron = r"Nota de (Crédito|Débito)"

        # Si el patrón se encuentra en el texto, retornar True
        return bool(re.search(patron, texto, re.IGNORECASE))

    paginas_con_nota = df[df['Region_1'].apply(detectar_nota_credito_debito)]['Pagina'].tolist()
    #eliminar paginas inessarias
    df = df[df['Region_1'].str.contains("Liquidación de Servicios", na=False, case=False)]

    # Mostrar el texto extraído de cada región
    #df.head(10)


    """EXTRAER DATOS DE LAS REGIONES"""
    #REGION 1
    def extraer_lsp(texto):
        # Busca el número de LSP en el formato esperado
        lsp = re.search(r'Liquidación de Servicios Públicos \(LSP\) B (\d{4}-\d{8}) \d+', texto)
        return lsp.group(1) if lsp else "No encontrado"

    def extraer_cliente(texto):
        # Busca el número de cliente
        cliente = re.search(r'Su número de cliente es\s*(\d+)', texto)
        return cliente.group(1) if cliente else "No encontrado"


    def extraer_destinatario(texto):
        # Elimina líneas que contienen las palabras específicas
        lineas_relevantes = [
            linea for linea in texto.splitlines()
            if not re.search(r'Liquidación|Cliente|N° de medidor|Hoja', linea)
        ]

        # Filtrar las líneas restantes y devolver la primera que no esté vacía
        for linea in lineas_relevantes:
            if linea.strip():  # Ignora líneas vacías
                return linea.strip()

        return "No encontrado"

    #region 2
    def extraer_vencimiento(texto):
        # Busca la fecha de vencimiento en el formato dd/mm/yyyy
        vencimiento = re.search(r'Esta liquidación vence el\s*(\d{2}/\d{2}/\d{4})', texto)
        return vencimiento.group(1) if vencimiento else "No encontrado"


    def extraer_total(texto):
        # Expresión regular para encontrar el total
        patron_total = r'\b(\d{1,3}(?:,\d{3})*\.\d{2})\b'
        total_match = re.findall(patron_total, texto)

        # Obtener el total si se encontró
        total = total_match[-1] if total_match else 'No encontrado'  # Obtenemos el último total si hay varios
        return total.strip()

    #region 3
    def extraer_medidor(texto):
        # Busca el número de medidor
        medidor = re.search(r'Nro Medidor\s*(\d+)', texto)
        return medidor.group(1) if medidor else "No encontrado"

    #region 4
    def extraer_fechas(texto):
        # Patrón para buscar fechas en formato dd/mm/aaaa
        patron_fecha = r'\b(\d{2}/\d{2}/\d{4})\b'

        # Buscar todas las fechas en el texto
        fechas = re.findall(patron_fecha, texto)

        # Si se encuentran al menos dos fechas, devolverlas como "Desde" y "Hasta"
        if len(fechas) >= 2:
            return pd.Series([fechas[0], fechas[1]])
        else:
            return pd.Series([None, None])  # Si no se encuentran suficientes fechas, devolver None

    #region 5
    def extraer_saldo_anterior(texto):
        # Buscar el saldo anterior
        saldo_patron = r'Saldo anterior\s*([\d,.]+)'
        saldo_match = re.search(saldo_patron, texto)
        saldo_anterior = saldo_match.group(1) if saldo_match else 'No encontrado'
        return saldo_anterior

    def extraer_bonificacion(texto):
        # Buscar la bonificación
        bonificacion_patron = r'Bonif_Interrupciones_Sem_\d+\s*([\d,.]+-)'
        bonificacion_match = re.search(bonificacion_patron, texto)
        bonificacion = bonificacion_match.group(1).replace('-', '') if bonificacion_match else 'No encontrado'
        return '-' + bonificacion if bonificacion != 'No encontrado' else bonificacion

    def extraer_interes_mora(texto):
        # Buscar el interés mora
        interes_mora_patron = r'Interés Mora\s*([\d,.]+)'
        interes_mora_match = re.search(interes_mora_patron, texto)
        interes_mora = interes_mora_match.group(1) if interes_mora_match else 'No encontrado'
        return interes_mora

    #region 6
    def extraer_fecha(texto):
        patron_fecha = r'\b(\d{2}/\d{2}/\d{4})\b'
        fecha_match = re.search(patron_fecha, texto)
        return fecha_match.group(1) if fecha_match else 'Fecha no encontrada'


    df['numero de factura'] = df['Region_1'].apply(extraer_lsp)
    df['Cliente'] = df['Region_1'].apply(extraer_cliente)
    df['Destinatario'] = df['Region_1'].apply(extraer_destinatario)
    df['Vencimiento'] = df['Region_2'].apply(extraer_vencimiento)
    df['Total'] = df['Region_2'].apply(extraer_total)
    df['Medidor'] = df['Region_3'].apply(extraer_medidor)
    df[['Desde', 'Hasta']] = df['Region_4'].apply(extraer_fechas)
    df['Saldo Anterior'] = df['Region_5'].apply(extraer_saldo_anterior)
    df['Bonificaciones'] = df['Region_5'].apply(extraer_bonificacion)
    df['Interés Mora'] = df['Region_5'].apply(extraer_interes_mora)
    df['Emision'] = df['Region_6'].apply(extraer_fecha)
    #df.head()

    """ Ajustar las columnas"""
    df.drop(columns=['Region_1', 'Region_2', 'Region_3', 'Region_4'], inplace=True)
    df['Cliente'] = pd.to_numeric(df['Cliente'], errors='coerce')
    df['Medidor'] = pd.to_numeric(df['Medidor'], errors='coerce')
    df['Total'] = df['Total'].str.replace(',', '').astype(float)
    df['Desde'] = pd.to_datetime(df['Desde'], format='%d/%m/%Y')
    df['Hasta'] = pd.to_datetime(df['Hasta'], format='%d/%m/%Y')
    df['Vencimiento'] = pd.to_datetime(df['Vencimiento'], format='%d/%m/%Y')
    df['Saldo Anterior'] = df['Saldo Anterior'].str.replace(',', '')
    df['Bonificaciones'] = df['Bonificaciones'].str.replace(',', '')
    df['Interés Mora'] = df['Interés Mora'].str.replace(',', '')
    df['Emision'] = pd.to_datetime(df['Emision'], format='%d/%m/%Y')

    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})-(\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)
        return "No encontrado", "No encontrado"

    # Aplicar la función y crear nuevas columnas
    df[['sucursal', 'factura']] = df['numero de factura'].apply(separar_codigo).apply(pd.Series)
    df = df.drop(columns=['numero de factura'])
    df['sucursal'] = pd.to_numeric(df['sucursal'], errors='coerce')
    df['factura'] = pd.to_numeric(df['factura'], errors='coerce')

    df.replace('No encontrado', 0, inplace=True)
    df['Saldo Anterior'] = df['Saldo Anterior'].astype(float)
    df['Bonificaciones'] = df['Bonificaciones'].astype(float)
    df['Interés Mora'] = df['Interés Mora'].astype(float)

    lista_nuevo_orden=['sucursal','factura','Cliente','Medidor','Emision','Vencimiento','Desde','Hasta','Saldo Anterior','Bonificaciones','Interés Mora','Total','Destinatario','Pagina']
    df = df[lista_nuevo_orden]
    df.head()

    """ADICIONALES"""
    def encontrar_saltos(paginas):
        saltos = []
        for i in range(1, len(paginas)):
            diferencia = paginas[i] - paginas[i - 1]
            if diferencia > 2:
                saltos.append((paginas[i - 1], paginas[i]))
        return saltos

    paginas = df['Pagina'].tolist()
    saltos_encontrados = encontrar_saltos(paginas)
    print("Saltos encontrados entre las siguientes páginas:")
    for inicio, fin in saltos_encontrados:
        print(f"Entre {inicio} y {fin}")
    print('cantidad total de saltos:', len(saltos_encontrados))
    print(f"Páginas con 'nota de crédito/débito': {paginas_con_nota}")


    """EXPORTAR"""
    nombre = 'EDESUR tarifa 2y3 facturas leidas.xlsx'
    df.to_excel(nombre, index=False)
    files.download(nombre)

"""METROGAS"""

def metrogas_simple():
    # @title

    metrogas_regiones = [(10,25,100,80),(30,85,370,130),(30,200,370,290),( 30,400,300,490),(300,510,570,650)]
    """cargar archivos"""
    uploaded = files.upload()

    """extraer texto"""

    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def procesar_varios_pdfs(lista_pdfs, regiones, pagina_numero=1):
        """
        Procesa varios archivos PDF y extrae las regiones definidas.

        Args:
        - lista_pdfs (list): Lista de rutas a los archivos PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).
        - pagina_numero (int): Número de la página a analizar (por defecto 1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada PDF.
        """
        # Lista para almacenar los datos de cada PDF
        datos_pdf = []

        # Iterar sobre cada archivo PDF
        for pdf_path in lista_pdfs:
            # Extraer texto de las regiones
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_pdf.append({
                "Archivo": pdf_path,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_pdf)

        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF

    regiones = metrogas_regiones  # Coordenadas de

    # Extraer texto de las regiones
    df = procesar_varios_pdfs(lista_pdfs ,regiones , 1)

    # Mostrar el texto extraído de cada región
    #df.head()

    """ Extracción de datos para cada una de las columnas"""

    # número de factura de Region_1
    def extraer_numero_factura(region_text):
        # Patrón relajado para el número de factura (por ejemplo: B-0064-07263496)
        patron_factura = r'(\bB-\d{4}-\d{8}\b)'
        factura = re.search(patron_factura, region_text)
        return factura.group(0) if factura else None

    # destinatario de Region_2 (mayúsculas consecutivas)
    def extraer_destinatario(region_text):
        patron_destinatario = r'([A-Z ]+)'  # Dos o más letras mayúsculas consecutivas
        destinatario = re.search(patron_destinatario, region_text)
        return destinatario.group(0).strip() if destinatario else None

    # número de cliente de Region_2
    def extraer_numero_cliente(region_text):
        # Buscar secuencias numéricas
        patron_numero_cliente = r'\b\d{8,12}\b'
        numero_cliente = re.search(patron_numero_cliente, region_text)
        return numero_cliente.group(0) if numero_cliente else None

    # fecha de emisión y fecha de vencimiento de Region_3
    def extraer_fechas_emision_vencimiento(region_text):
        # Patrón para fechas en formato dd/mm/aaaa

        patron_fecha = r'(\d{2}/\d{2}/\d{4})'
        fechas = re.findall(patron_fecha, region_text)
        if len(fechas) >= 2:
            return fechas[1], fechas[0]  # Vencimiento primero, emisión segundo
        return None, None

    # TOTAL
    def extraer_total(region_text):
        patron_total = r'\$\s?([0-9.,]+)'
        total = re.search(patron_total, region_text)
        return total.group(1) if total else None

    # fechas desde y hasta de Region_4
    def extraer_fecha_desde_hasta(region_text):
        patron_fecha = r'(\d{2}/\d{2}/\d{4})'
        fechas = re.findall(patron_fecha, region_text)
        if len(fechas) >= 2:
            return fechas[0], fechas[1]  # Desde, Hasta
        return None, None

    # "Gestión y Envío" de Region_5
    def extraer_gestion_envio(region_text):
        # Buscar la frase "GEST Y ENVIO AV.DEUDA" en el texto
        patron_gestion = r'GEST Y ENVIO AV\.DEUDA'
        gestion_envio_match = re.search(patron_gestion, region_text, re.IGNORECASE)

        if gestion_envio_match:
            # Buscar el monto que puede estar en la misma línea o en una línea diferente
            # Capturamos el monto en cualquier línea posterior a la frase "GEST Y ENVIO AV.DEUDA"
            patron_monto = r'GEST Y ENVIO AV\.DEUDA.*?([\d\.,]+)'
            monto_match = re.search(patron_monto, region_text, re.IGNORECASE | re.DOTALL)

            return monto_match.group(1) if monto_match else None

        return None


    # IVA 27% de Region_5
    def extraer_iva_27(region_text):
        patron_iva = r'IVA DIFERENCIAL 27 % DE [\d\.,]+\s*([\d\.,]+)'
        iva = re.search(patron_iva, region_text)
        return iva.group(1) if iva else None

    # Aplicar las funciones a cada columna del DataFrame
    df['Numero_Factura'] = df['Region_1'].apply(extraer_numero_factura)
    df['Destinatario'] = df['Region_2'].apply(extraer_destinatario)
    df['Fecha_Vencimiento'], df['Fecha_Emision'] = zip(*df['Region_3'].apply(extraer_fechas_emision_vencimiento))
    df['Total'] = df['Region_3'].apply(extraer_total)
    df['Fecha_Desde'], df['Fecha_Hasta'] = zip(*df['Region_4'].apply(extraer_fecha_desde_hasta))
    df['Gestion_Envio'] = df['Region_5'].apply(extraer_gestion_envio)
    df['IVA_27'] = df['Region_5'].apply(extraer_iva_27)
    df['Numero_Cliente'] = df['Region_2'].apply(extraer_numero_cliente)


    #limpiar las columnas
    df['Total']= df['Total'].str.replace('.', '')
    df['Total']= df['Total'].str.replace(',', '.')
    df['Gestion_Envio']= df['Gestion_Envio'].str.replace('.', '')
    df['Gestion_Envio']= df['Gestion_Envio'].str.replace(',', '.')
    df['IVA_27']= df['IVA_27'].str.replace('.', '')
    df['IVA_27']= df['IVA_27'].str.replace(',', '.')
    #Dar formato a las columnas
    df['Total']= pd.to_numeric(df['Total'], errors = 'coerce')
    df['Numero_Cliente'] = pd.to_numeric(df['Numero_Cliente'], errors='coerce')
    df['Fecha_Vencimiento'] = pd.to_datetime(df['Fecha_Vencimiento'], format='%d/%m/%Y')
    df['Fecha_Emision'] = pd.to_datetime(df['Fecha_Emision'], format='%d/%m/%Y')
    df['Fecha_Hasta'] = pd.to_datetime(df['Fecha_Hasta'], format='%d/%m/%Y')
    df['Fecha_Desde'] = pd.to_datetime(df['Fecha_Desde'], format='%d/%m/%Y')
    df['Gestion_Envio']= pd.to_numeric(df['Gestion_Envio'], errors='coerce').fillna(0)
    df['IVA_27']= pd.to_numeric(df['IVA_27'], errors='coerce').fillna(0)

    #generar y eliminar columnas innecesarias
    df[['sucursal', 'factura']] = df['Numero_Factura'].str.extract(r'B-(\d{4})-(\d{8})')
    df['sucursal'] = pd.to_numeric(df['sucursal'])
    df['factura'  ] = pd.to_numeric(df['factura'])
    df.drop(columns=['Region_1', 'Region_2', 'Region_3', 'Region_4', 'Region_5','Numero_Factura'], inplace=True)
    df.fillna(0, inplace=True)

    columnas_orden = ['sucursal', 'factura', 'Numero_Cliente', 'Fecha_Vencimiento',
                      'Fecha_Emision', 'Fecha_Desde', 'Fecha_Hasta',
                      'Gestion_Envio', 'IVA_27', 'Total', 'Archivo', 'Destinatario']

    df = df[columnas_orden]
    #df.head()

    """exportar el dataframe"""
    nombre='Facturas leidas metrogas.xlsx'
    df.to_excel(nombre, index = False)
    files.download(nombre)

def metrogas_unificado():
    # @title
    metrogas_regiones = [(10,25,100,80),(30,85,370,130),(30,200,370,290),( 30,400,300,490),(300,510,570,650)]

    uploaded = files.upload()

    #para varios como un dataframe

    """EXTRAER TEXTO EN UN DF"""

    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def obtener_numero_paginas(pdf_path):
        """
        Obtiene el número total de páginas en un archivo PDF.

        Args:
        - pdf_path (str): Ruta al archivo PDF.

        Returns:
        - int: Número total de páginas en el PDF.
        """
        with fitz.open(pdf_path) as pdf:
            num_paginas = pdf.page_count
        return num_paginas


    def procesar_pdf_con_varias_paginas(pdf_path, regiones):
        """
        Procesa un archivo PDF con múltiples páginas y extrae las regiones definidas.

        Args:
        - pdf_path (str): Ruta al archivo PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada página del PDF.
        """
        # Lista para almacenar los datos de cada página del PDF
        datos_paginas = []

        # Obtener el número total de páginas del PDF
        num_paginas = obtener_numero_paginas(pdf_path)

        # Iterar sobre cada página del PDF
        for pagina_numero in range(1, num_paginas + 1):
            # Extraer texto de las regiones en la página actual
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_paginas.append({
                "Archivo": pdf_path,
                "Pagina": pagina_numero,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_paginas)

        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF

    file_path = next(iter(uploaded.keys()))

    regiones = metrogas_regiones  # Coordenadas de

    # Extraer texto de las regiones
    df = procesar_pdf_con_varias_paginas(file_path ,regiones )

    # Mostrar el texto extraído de cada región
    #df.head(10)

    """EXTRAER DATOS"""
    import re

    # Supongamos que ya tienes un DataFrame llamado df con las columnas Region_1, Region_2, etc.
    # Aquí aplicamos la extracción de datos para cada una de las columnas.

    df = df[df['Region_1'].str.strip() != '']

    # número de factura de Region_1
    def extraer_numero_factura(region_text):
        # Patrón relajado para el número de factura (por ejemplo: B-0064-07263496)
        patron_factura = r'(\bB-\d{4}-\d{8}\b)'
        factura = re.search(patron_factura, region_text)
        return factura.group(0) if factura else None

    # destinatario de Region_2 (mayúsculas consecutivas)
    def extraer_destinatario(region_text):
        patron_destinatario = r'([A-Z ]+)'  # Dos o más letras mayúsculas consecutivas
        destinatario = re.search(patron_destinatario, region_text)
        return destinatario.group(0).strip() if destinatario else None

    # número de cliente (una secuencia numérica, puede estar en varias ubicaciones)
    def extraer_numero_cliente(region_text):
        # Buscar secuencias numéricas
        patron_numero_cliente = r'\b\d{8,12}\b'
        numero_cliente = re.search(patron_numero_cliente, region_text)
        return numero_cliente.group(0) if numero_cliente else None

    # fecha de emisión y fecha de vencimiento de Region_3
    def extraer_fechas_emision_vencimiento(region_text):
        # Patrón para fechas en formato dd/mm/aaaa

        patron_fecha = r'(\d{2}/\d{2}/\d{4})'
        fechas = re.findall(patron_fecha, region_text)
        if len(fechas) >= 2:
            return fechas[1], fechas[0]  # Vencimiento primero, emisión segundo
        return None, None

    # TOTAL
    def extraer_total(region_text):
        patron_total = r'\$\s?([0-9.,]+)'
        total = re.search(patron_total, region_text)
        return total.group(1) if total else None

    # fechas desde y hasta de Region_4
    def extraer_fecha_desde_hasta(region_text):
        patron_fecha = r'(\d{2}/\d{2}/\d{4})'
        fechas = re.findall(patron_fecha, region_text)
        if len(fechas) >= 2:
            return fechas[0], fechas[1]  # Desde, Hasta
        return None, None

    # "Gestión y Envío" de Region_5
    def extraer_gestion_envio(region_text):
        # Buscar la frase "GEST Y ENVIO AV.DEUDA" en el texto
        patron_gestion = r'GEST Y ENVIO AV\.DEUDA'
        gestion_envio_match = re.search(patron_gestion, region_text, re.IGNORECASE)

        if gestion_envio_match:
            # Buscar el monto que puede estar en la misma línea o en una línea diferente
            # Capturamos el monto en cualquier línea posterior a la frase "GEST Y ENVIO AV.DEUDA"
            patron_monto = r'GEST Y ENVIO AV\.DEUDA.*?([\d\.,]+)'
            monto_match = re.search(patron_monto, region_text, re.IGNORECASE | re.DOTALL)

            return monto_match.group(1) if monto_match else None

        return None

    # IVA 27% de Region_5
    def extraer_iva_27(region_text):
        patron_iva = r'IVA DIFERENCIAL 27 % DE [\d\.,]+\s*([\d\.,]+)'
        iva = re.search(patron_iva, region_text)
        return iva.group(1) if iva else None

    # Aplicar las funciones a cada columna del DataFrame
    df['Numero_Factura'] = df['Region_1'].apply(extraer_numero_factura)
    df['Destinatario'] = df['Region_2'].apply(extraer_destinatario)
    df['Fecha_Vencimiento'], df['Fecha_Emision'] = zip(*df['Region_3'].apply(extraer_fechas_emision_vencimiento))
    df['Total'] = df['Region_3'].apply(extraer_total)
    df['Fecha_Desde'], df['Fecha_Hasta'] = zip(*df['Region_4'].apply(extraer_fecha_desde_hasta))
    df['Gestion_Envio'] = df['Region_5'].apply(extraer_gestion_envio)
    df['IVA_27'] = df['Region_5'].apply(extraer_iva_27)
    df['Numero_Cliente'] = df['Region_2'].apply(extraer_numero_cliente)

    # Mostrar el DataFrame actualizado
    #df[['Pagina','Numero_Factura','Numero_Cliente', 'Destinatario', 'Fecha_Vencimiento', 'Fecha_Emision', 'Total', 'Fecha_Desde', 'Fecha_Hasta', 'Gestion_Envio', 'IVA_27']].head()

    """RETOCAR EL DF"""

    #limpiar las columnas
    df['Total']= df['Total'].str.replace('.', '')
    df['Total']= df['Total'].str.replace(',', '.')
    df['Gestion_Envio']= df['Gestion_Envio'].str.replace('.', '')
    df['Gestion_Envio']= df['Gestion_Envio'].str.replace(',', '.')
    df['IVA_27']= df['IVA_27'].str.replace('.', '')
    df['IVA_27']= df['IVA_27'].str.replace(',', '.')
    #Dar formato a las columnas
    df['Total']= pd.to_numeric(df['Total'], errors = 'coerce')
    df['Numero_Cliente'] = pd.to_numeric(df['Numero_Cliente'], errors='coerce')
    df['Fecha_Vencimiento'] = pd.to_datetime(df['Fecha_Vencimiento'], format='%d/%m/%Y')
    df['Fecha_Emision'] = pd.to_datetime(df['Fecha_Emision'], format='%d/%m/%Y')
    df['Fecha_Hasta'] = pd.to_datetime(df['Fecha_Hasta'], format='%d/%m/%Y')
    df['Fecha_Desde'] = pd.to_datetime(df['Fecha_Desde'], format='%d/%m/%Y')
    df['Gestion_Envio']= pd.to_numeric(df['Gestion_Envio'], errors='coerce').fillna(0)
    df['IVA_27']= pd.to_numeric(df['IVA_27'], errors='coerce').fillna(0)

    df[['sucursal', 'factura']] = df['Numero_Factura'].str.extract(r'B-(\d{4})-(\d{8})')
    df['sucursal'] = pd.to_numeric(df['sucursal'])
    df['factura'  ] = pd.to_numeric(df['factura'])
    df.drop(columns=['Region_1', 'Region_2', 'Region_3', 'Region_4', 'Region_5','Numero_Factura'], inplace=True)
    df.fillna(0, inplace=True)

    columnas_orden = ['sucursal', 'factura', 'Numero_Cliente', 'Fecha_Vencimiento',
                      'Fecha_Emision', 'Fecha_Desde', 'Fecha_Hasta',
                      'Gestion_Envio', 'IVA_27', 'Total', 'Pagina', 'Destinatario']

    # Reordenar el DataFrame usando df[]
    df = df[columnas_orden]
    #df.head()

    """ADICIONALES"""
    def encontrar_saltos(paginas):
        saltos = []
        for i in range(1, len(paginas)):
            diferencia = paginas[i] - paginas[i - 1]
            if diferencia > 2:
                saltos.append((paginas[i - 1], paginas[i]))
        return saltos

    # Ejemplo de uso
    paginas = df['Pagina'].tolist()
    saltos_encontrados = encontrar_saltos(paginas)
    print("Saltos encontrados entre las siguientes páginas:")
    for inicio, fin in saltos_encontrados:
        print(f"Entre {inicio} y {fin}")

    """EXPORTAR"""
    nombre = 'facturas leidas.xlsx'
    df.to_excel(nombre, index = False)
    files.download(nombre)

"""TASA"""

def tasa_simple():
    # @title
    #para uno por pdf
    TASA_regiones = [(360,55,570,165),(20,90,270,150),(50,225,150,270),(420,225,500,270)]

    """cargar archivos"""
    uploaded = files.upload()


    """EXTRAER REGIONES Y ARMAR EL DF"""
    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def procesar_varios_pdfs(lista_pdfs, regiones, pagina_numero=1):
        """
        Procesa varios archivos PDF y extrae las regiones definidas.

        Args:
        - lista_pdfs (list): Lista de rutas a los archivos PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).
        - pagina_numero (int): Número de la página a analizar (por defecto 1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada PDF.
        """
        # Lista para almacenar los datos de cada PDF
        datos_pdf = []

        # Iterar sobre cada archivo PDF
        for pdf_path in lista_pdfs:
            # Extraer texto de las regiones
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_pdf.append({
                "Archivo": pdf_path,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_pdf)

        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF

    regiones = TASA_regiones  # Coordenadas de

    # Extraer texto de las regiones
    df = procesar_varios_pdfs(lista_pdfs ,regiones , 1)

    # Mostrar el texto extraído de cada región
    #df.head(10)

    """EXTRAER DATOS DE LAS REGIONES"""

    # Función para extraer el número de factura
    def extraer_numero_factura(texto):
        patron = r'Factura\s*(\d{4}-\d{8})'
        match = re.search(patron, texto)
        return match.group(1) if match else "No encontrado"

    # Función para extraer la fecha de emisión
    def extraer_fecha_emision(texto):
        patron = r'Fecha de emisión:\s*(\d{2}/\d{2}/\d{4})'
        match = re.search(patron, texto)
        return match.group(1) if match else "No encontrado"

    # Función para extraer el total a pagar
    def extraer_total_a_pagar(texto):
        patron = r'Total a Pagar:\s*\$?([\d,.]+)'
        match = re.search(patron, texto)
        return match.group(1) if match else "No encontrado"

    # Función para extraer la fecha de vencimiento
    def extraer_fecha_vencimiento(texto):
        patron = r'Vencimiento:\s*(\d{2}/\d{2}/\d{4})'
        match = re.search(patron, texto)

        return match.group(1) if match else "No encontrado"

    # Función para extraer el número de línea
    def extraer_numero_linea(texto):
        patron = r'Línea:\s*(\d+)'
        match = re.search(patron, texto)
        return match.group(1) if match else "No encontrado"

    # Función para extraer el número de cliente
    def extraer_numero_cliente(texto):
        patron = r'Cliente Nº:\s*(\d+)'
        match = re.search(patron, texto)
        return match.group(1) if match else "No encontrado"

    # extraer direccion de la region 2
    def extraer_direccion(texto):
        # El patrón busca todo antes de un código entre paréntesis
        patron = r'^(.*?)\s*\([A-Z0-9]+\)'
        match = re.search(patron, texto, re.DOTALL)  # DOTALL permite capturar saltos de línea
        return match.group(1).strip() if match else "No encontrado"

    #extraer montos de la region 3 (SALDO ANTERIOR) Y region 4 (cargos del periodo)
    def extraer_montos(texto):
        # El patrón busca montos con o sin símbolo de moneda y con miles/decimales
        patron = r'\$\s?[\d.,]+'  # Captura números con puntos, comas y opcionalmente el símbolo $
        montos = re.findall(patron, texto)

        # Devuelve el primer monto o un mensaje si no se encuentra ninguno
        return montos[0] if montos else "No se encontró ningún monto"


    # aplicar las funciones
    df['Facturas'] = df['Region_1'].apply(extraer_numero_factura)
    df['Fecha de Emision'] = df['Region_1'].apply(extraer_fecha_emision)
    df['Total'] = df['Region_1'].apply(extraer_total_a_pagar)
    df['Fecha De Vencimiento'] = df['Region_1'].apply(extraer_fecha_vencimiento)
    df['Numero de linea'] = df['Region_1'].apply(extraer_numero_linea)
    df['Cliente'] = df['Region_1'].apply(extraer_numero_cliente)
    df['Direccion'] = df['Region_2'].apply(extraer_direccion)
    df['Saldo Anterior'] = df['Region_3'].apply(extraer_montos)
    df['Total a pagar'] = df['Region_4'].apply(extraer_montos)
    #df.head()

    """EXTARER TELEFONOGRAMAS Y PERIODO"""
    def extraer_telefonogramas(pdf_path):
        # Abrir el documento PDF
        doc = fitz.open(pdf_path)

        # Definir el texto a buscar
        text_to_find = "Telefonogramas"

        # Iterar a través de las páginas
        for page_num in range(len(doc)):
            page = doc[page_num]

            # Buscar el texto y obtener sus coordenadas
            text_instances = page.search_for(text_to_find)

            for inst in text_instances:
                # inst es un rectángulo que rodea el texto encontrado
                rect = fitz.Rect(inst)

                # Ampliar el rectángulo en el eje X (aumentar ancho)
                expanded_rect = fitz.Rect(rect.x0 - 50, rect.y0, rect.x1 + 500, rect.y1 + 20)

                # Extraer el texto dentro del rectángulo expandido
                extracted_text = page.get_text("text", clip=expanded_rect)

                # Definir el patrón para encontrar montos
                pattern = r'\b\d{1,3}(?:\.\d{3})*(?:[,.]\d{2})?|\b\d+(?:[,.]\d{2})?\b'

                # Buscar todos los posibles montos dentro del texto extraído
                matches = re.findall(pattern, extracted_text)

                # Filtrar los montos encontrados
                if matches:
                    # Tomar el último monto encontrado y normalizarlo
                    monto = matches[-1].replace('.', '').replace(',', '.')  # Normaliza el formato
                    doc.close()  # Cerrar el documento antes de devolver el monto
                    return monto

        # Cerrar el documento si no se encuentra ningún monto
        doc.close()
        return None

    #extraer periodo
    def extraer_periodo(pdf_path):
        doc = fitz.open(pdf_path)
        fechas_encontradas = []
        frase_referencia = "PLANES Y SERVICIOS"

        for page_num in range(len(doc)):
            page = doc[page_num]
            text_instances = page.search_for(frase_referencia)

            for inst in text_instances:
                rect = fitz.Rect(inst)
                # Expandir el rectángulo en el eje X positivo
                expanded_rect = fitz.Rect(rect.x1, rect.y0, rect.x1 + 300, rect.y1)

                # Extraer el texto dentro del rectángulo expandido
                extracted_text = page.get_text("text", clip=expanded_rect)

                # Buscar dos fechas dentro del texto extraído (ajusta el patrón según tu formato de fecha)
                pattern = r'\d{2}/\d{2}'  # Busca fechas en formato dd/mm/yyyy
                matches = re.findall(pattern, extracted_text)

                if len(matches) >= 2:
                    fechas_encontradas.extend(matches[:2])  # Toma las primeras dos fechas encontradas
                    break  # Si se encontraron dos fechas, salir del bucle interno

        doc.close()
        return fechas_encontradas

    #dar formato a las fechas
    def completar_fecha(fecha_str):
      """Completa una fecha dd/mm a dd/mm/aaaa asumiendo el año actual."""
      if len(fecha_str.split('/')) == 2:
        import datetime
        año_actual = datetime.datetime.now().year
        return f"{fecha_str}/{año_actual}"
      return fecha_str

    #agregarlas al df
    df['Telefonogramas'] = df['Archivo'].apply(extraer_telefonogramas)
    df['Desde'] = df['Archivo'].apply(extraer_periodo).apply(pd.Series)[0]
    df['Hasta'] = df['Archivo'].apply(extraer_periodo).apply(pd.Series)[1]
    df['Desde'] = df['Desde'].apply(completar_fecha)
    df['Hasta'] = df['Hasta'].apply(completar_fecha)
    df.drop(columns=['Region_1', 'Region_2', 'Region_3','Region_4'], inplace=True)

    """DAR FORMATO AL DF"""
    #ajustar las columnas
    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})-(\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)
        return "No encontrado", "No encontrado"

    df[['sucursal','factura']] = df['Facturas'].apply(separar_codigo).apply(pd.Series)
    df.drop(columns=['Facturas'], inplace=True)
    df['Fecha de Emision'] = pd.to_datetime(df['Fecha de Emision'], format='%d/%m/%Y')
    df['Fecha De Vencimiento'] = pd.to_datetime(df['Fecha De Vencimiento'], format='%d/%m/%Y')
    df['Saldo Anterior'] = df['Saldo Anterior'].str.replace('$', '').str.replace('.', '').str.replace(',','.').astype(float)
    df['Total a pagar'] = df['Total a pagar'].str.replace('$', '').str.replace('.', '').str.replace(',','.').astype(float)
    df['Saldo Anterior'] = df['Saldo Anterior'].astype(float)
    df['Total a pagar'] = df['Total a pagar'].astype(float)
    df['Desde'] = pd.to_datetime(df['Desde'],format='%d/%m/%Y')
    df['Hasta'] = pd.to_datetime(df['Hasta'],format='%d/%m/%Y')
    df['Telefonogramas'] = df['Telefonogramas'].astype(float)
    df['Cliente'] = df['Cliente'].astype(int)
    df['Total'] = df['Total'].str.replace('$', '').str.replace('.', '').str.replace(',','.').astype(float)
    df.fillna(0, inplace=True)
    #cambiar el orden
    nuevo_orden = ['sucursal', 'factura', 'Cliente', 'Numero de linea', 'Fecha de Emision', 'Fecha De Vencimiento', 'Desde', 'Hasta', 'Saldo Anterior', 'Total a pagar', 'Telefonogramas', 'Total', 'Direccion', 'Archivo']
    df = df[nuevo_orden]
    df.head()

    """EXPORTAR EN EXCEL"""

    nombre_archivo = 'TASA facturas leidas.xlsx'
    df.to_excel(nombre_archivo, index=False)
    files.download(nombre_archivo)

def tasa_unificado():
    # @title
    #para varios como un dataframe
    TASA_regiones = [(360,55,570,165),(20,90,270,150),(50,225,150,270),(420,225,500,270)]
    """CARGAR EL ARCHIVO"""
    uploaded = files.upload()
    file_path = list(uploaded.keys())[0]

    """EXTRAER REGIONES Y ARMAR EL DF"""
    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def obtener_numero_paginas(pdf_path):
        """
        Obtiene el número total de páginas en un archivo PDF.

        Args:
        - pdf_path (str): Ruta al archivo PDF.

        Returns:
        - int: Número total de páginas en el PDF.
        """
        with fitz.open(pdf_path) as pdf:
            num_paginas = pdf.page_count
        return num_paginas


    def procesar_pdf_con_varias_paginas(pdf_path, regiones):
        """
        Procesa un archivo PDF con múltiples páginas y extrae las regiones definidas.

        Args:
        - pdf_path (str): Ruta al archivo PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada página del PDF.
        """
        # Lista para almacenar los datos de cada página del PDF
        datos_paginas = []

        # Obtener el número total de páginas del PDF
        num_paginas = obtener_numero_paginas(pdf_path)

        # Iterar sobre cada página del PDF
        for pagina_numero in range(1, num_paginas + 1):
            # Extraer texto de las regiones en la página actual
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_paginas.append({
                "Archivo": pdf_path,
                "Pagina": pagina_numero,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_paginas)

        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF

    file_path = next(iter(uploaded.keys()))

    regiones = TASA_regiones  # Coordenadas de

    # Extraer texto de las regiones
    df = procesar_pdf_con_varias_paginas(file_path ,regiones )

    # filtrar el texto
    df = df[df['Region_1'].str.contains("1/", na=False, case=False)]
    #df.head()

    """EXTRAER DATOS DE LAS REGIONES"""

    # Función para extraer el número de factura
    def extraer_numero_factura(texto):
        patron = r'Factura\s*(\d{4}-\d{8})'
        match = re.search(patron, texto)
        return match.group(1) if match else "No encontrado"

    # Función para extraer la fecha de emisión
    def extraer_fecha_emision(texto):
        patron = r'Fecha de emisión:\s*(\d{2}/\d{2}/\d{4})'
        match = re.search(patron, texto)
        return match.group(1) if match else "No encontrado"

    # Función para extraer el total a pagar
    def extraer_total_a_pagar(texto):
        patron = r'Total a Pagar:\s*\$?([\d,.]+)'
        match = re.search(patron, texto)
        return match.group(1) if match else "No encontrado"

    # Función para extraer la fecha de vencimiento
    def extraer_fecha_vencimiento(texto):
        patron = r'Vencimiento:\s*(\d{2}/\d{2}/\d{4})'
        match = re.search(patron, texto)

        return match.group(1) if match else "No encontrado"

    # Función para extraer el número de línea
    def extraer_numero_linea(texto):
        patron = r'Línea:\s*(\d+)'
        match = re.search(patron, texto)
        return match.group(1) if match else "No encontrado"

    # Función para extraer el número de cliente
    def extraer_numero_cliente(texto):
        patron = r'Cliente Nº:\s*(\d+)'
        match = re.search(patron, texto)
        return match.group(1) if match else "No encontrado"

    # extraer direccion de la region 2
    def extraer_direccion(texto):
        # El patrón busca todo antes de un código entre paréntesis
        patron = r'^(.*?)\s*\([A-Z0-9]+\)'
        match = re.search(patron, texto, re.DOTALL)  # DOTALL permite capturar saltos de línea
        return match.group(1).strip() if match else "No encontrado"

    #extraer montos de la region 3 (SALDO ANTERIOR) Y region 4 (cargos del periodo)
    def extraer_montos(texto):
        # El patrón busca montos con o sin símbolo de moneda y con miles/decimales
        patron = r'\$\s?[\d.,]+'  # Captura números con puntos, comas y opcionalmente el símbolo $
        montos = re.findall(patron, texto)

        # Devuelve el primer monto o un mensaje si no se encuentra ninguno
        return montos[0] if montos else "No se encontró ningún monto"


    # aplicar las funciones
    df['Facturas'] = df['Region_1'].apply(extraer_numero_factura)
    df['Fecha de Emision'] = df['Region_1'].apply(extraer_fecha_emision)
    df['Total'] = df['Region_1'].apply(extraer_total_a_pagar)
    df['Fecha De Vencimiento'] = df['Region_1'].apply(extraer_fecha_vencimiento)
    df['Numero de linea'] = df['Region_1'].apply(extraer_numero_linea)
    df['Cliente'] = df['Region_1'].apply(extraer_numero_cliente)
    df['Direccion'] = df['Region_2'].apply(extraer_direccion)
    df['Saldo Anterior'] = df['Region_3'].apply(extraer_montos)
    df['Total a pagar'] = df['Region_4'].apply(extraer_montos)
    #df.head()

    """EXTRAER TELEFONOGRAMAS Y PERIODO"""
    #extraer telefonogramas
    def extraer_telefonogramas(pagina_actual, paginas_lista):
        # Ruta fija del documento PDF
        pdf_path = file_path  # Cambia esta ruta a tu archivo PDF
        doc = fitz.open(pdf_path)

        # Definir el texto a buscar
        text_to_find = "Telefonogramas"

        # Determinar el índice de la página actual
        try:
            index_actual = paginas_lista.index(pagina_actual)
        except ValueError:
            doc.close()
            return None

        # Determinar la siguiente página, si existe
        pagina_siguiente = paginas_lista[index_actual + 1] if index_actual + 1 < len(paginas_lista) else None

        # Iterar sobre las páginas desde la actual hasta la siguiente
        for page_num in range(pagina_actual - 1, (pagina_siguiente or pagina_actual) - 1):
            page = doc[page_num]

            # Buscar el texto y obtener sus coordenadas
            text_instances = page.search_for(text_to_find)

            # Si se encuentran instancias del texto, procesar
            if text_instances:
                for inst in text_instances:
                    # inst es un rectángulo que rodea el texto encontrado
                    rect = fitz.Rect(inst)

                    # Ampliar el rectángulo en el eje X (aumentar ancho)
                    expanded_rect = fitz.Rect(rect.x0 - 50, rect.y0, rect.x1 + 500, rect.y1 + 20)

                    # Extraer el texto dentro del rectángulo expandido
                    extracted_text = page.get_text("text", clip=expanded_rect)

                    # Definir el patrón para encontrar montos
                    pattern = r'\b\d{1,3}(?:\.\d{3})*(?:[,.]\d{2})?|\b\d+(?:[,.]\d{2})?\b'

                    # Buscar todos los posibles montos dentro del texto extraído
                    matches = re.findall(pattern, extracted_text)

                    # Filtrar los montos encontrados
                    if matches:
                        # Tomar el último monto encontrado y normalizarlo
                        monto = matches[-1].replace('.', '').replace(',', '.')  # Normaliza el formato
                        doc.close()  # Cerrar el documento antes de devolver el monto
                        return monto

        # Cerrar el documento si no se encuentra ningún monto
        doc.close()
        return None

    #extraer periodo
    def extraer_periodo(start_page):
        pdf_path = file_path  # Cambia esto a la ruta de tu PDF
        doc = fitz.open(pdf_path)
        fechas_encontradas = []
        frase_referencia = "PLANES Y SERVICIOS"  # Búsqueda exacta en mayúsculas

        # Ajustar el rango de páginas a buscar, comenzando desde la página especificada
        for page_num in range(start_page - 1, len(doc)):  # -1 porque `fitz` usa índices basados en 0
            page = doc[page_num]
            text_instances = page.search_for(frase_referencia)

            for inst in text_instances:
                rect = fitz.Rect(inst)
                # Expandir el rectángulo en el eje X positivo
                expanded_rect = fitz.Rect(rect.x0, rect.y0, rect.x1 + 300, rect.y1)

                # Extraer el texto dentro del rectángulo expandido
                extracted_text = page.get_text("text", clip=expanded_rect)

                # Buscar dos fechas dentro del texto extraído (ajusta el patrón según tu formato de fecha)
                pattern = r'\d{2}/\d{2}'  # Busca fechas en formato dd/mm
                matches = re.findall(pattern, extracted_text)

                if len(matches) >= 2:
                    fechas_encontradas.extend(matches[:2])  # Toma las primeras dos fechas encontradas
                    break  # Si se encontraron dos fechas, salir del bucle interno

        doc.close()
        return fechas_encontradas


    #dar formato a las fechas
    def completar_fecha(fecha_str):
      """Completa una fecha dd/mm a dd/mm/aaaa asumiendo el año actual."""
      if len(fecha_str.split('/')) == 2:
        import datetime
        año_actual = datetime.datetime.now().year
        return f"{fecha_str}/{año_actual}"
      return fecha_str

    #aplicar la funcion para telefonograma
    df['Telefonogramas'] = df['Pagina'].apply(lambda pagina: extraer_telefonogramas(pagina, df['Pagina'].tolist()))
    df['Desde'] = df['Pagina'].apply(extraer_periodo).apply(pd.Series)[0]
    df['Hasta'] = df['Pagina'].apply(extraer_periodo).apply(pd.Series)[1]
    df['Desde'] = df['Desde'].apply(completar_fecha)
    df['Hasta'] = df['Hasta'].apply(completar_fecha)
    #df.head()

    """AJUSTAR EL DATAFRAME"""
    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})-(\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)
        return "No encontrado", "No encontrado"

    df[['sucursal','factura']] = df['Facturas'].apply(separar_codigo).apply(pd.Series)
    df.drop(columns=['Facturas'], inplace=True)
    df['Fecha de Emision'] = pd.to_datetime(df['Fecha de Emision'], format='%d/%m/%Y')
    df['Fecha De Vencimiento'] = pd.to_datetime(df['Fecha De Vencimiento'], format='%d/%m/%Y')
    df['Saldo Anterior'] = df['Saldo Anterior'].str.replace('$', '').str.replace('.', '').str.replace(',','.').astype(float)
    df['Total a pagar'] = df['Total a pagar'].str.replace('$', '').str.replace('.', '').str.replace(',','.').astype(float)
    df['Saldo Anterior'] = df['Saldo Anterior'].astype(float)
    df['Total a pagar'] = df['Total a pagar'].astype(float)
    df['Desde'] = pd.to_datetime(df['Desde'],format='%d/%m/%Y')
    df['Hasta'] = pd.to_datetime(df['Hasta'],format='%d/%m/%Y')
    df['Telefonogramas'] = df['Telefonogramas'].astype(float)
    df['Cliente'] = df['Cliente'].astype(int)
    df['Total'] = df['Total'].str.replace('$', '').str.replace('.', '').str.replace(',','.').astype(float)
    df.fillna(0, inplace=True)
    #cambiar el orden
    nuevo_orden = ['sucursal', 'factura', 'Cliente', 'Numero de linea', 'Fecha de Emision', 'Fecha De Vencimiento', 'Desde', 'Hasta', 'Saldo Anterior', 'Total a pagar', 'Telefonogramas', 'Total', 'Direccion', 'Pagina']
    df = df[nuevo_orden]
    df.head()

    """ADICIONALES"""
    def encontrar_saltos(paginas):
        saltos = []
        for i in range(1, len(paginas)):
            diferencia = paginas[i] - paginas[i - 1]
            if diferencia > 2:
                saltos.append((paginas[i - 1], paginas[i]))
        return saltos

    # Ejemplo de uso
    paginas = df['Pagina'].tolist()
    saltos_encontrados = encontrar_saltos(paginas)
    print("Saltos encontrados entre las siguientes páginas:")
    for inicio, fin in saltos_encontrados:
        print(f"Entre {inicio} y {fin}")


    """EXPORTAR EN EXCEL"""

    nombre_archivo = 'TASA facturas leidas.xlsx'
    df.to_excel(nombre_archivo, index=False)
    files.download(nombre_archivo)

"""TECO"""

def teco1_simple():
    # @title
    TECO_regiones = [(390,50,570,130),(30,80,250,150),(300,170,570,280),(95,300,350,390)]

    """cargar el archivo y generar el df"""
    uploaded = files.upload()
    filename = list(uploaded.keys())[0]

    """extraer texto y armar el df"""
    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def procesar_varios_pdfs(lista_pdfs, regiones, pagina_numero=1):
        """
        Procesa varios archivos PDF y extrae las regiones definidas.

        Args:
        - lista_pdfs (list): Lista de rutas a los archivos PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).
        - pagina_numero (int): Número de la página a analizar (por defecto 1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada PDF.
        """
        # Lista para almacenar los datos de cada PDF
        datos_pdf = []

        # Iterar sobre cada archivo PDF
        for pdf_path in lista_pdfs:
            # Extraer texto de las regiones
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_pdf.append({
                "Archivo": pdf_path,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_pdf)

        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF
    regiones = TECO_regiones  # Coordenadas de
    # Extraer texto de las regiones
    df = procesar_varios_pdfs(lista_pdfs ,regiones , 1)

    """filtro"""


    #region 1
    def extraer_total_a_pagar(texto):
        """Extrae el total a pagar del texto de la factura."""
        patron_total = r'TOTAL A PAGAR\s*([\d.,]+)'
        total = re.search(patron_total, texto)
        return total.group(1) if total else None

    def extraer_vencimiento(texto):
        """Extrae la fecha de vencimiento del texto de la factura."""
        patron_vencimiento = r'VENCIMIENTO\s*(\d{2}/\d{2}/\d{4})'
        vencimiento = re.search(patron_vencimiento, texto)
        return vencimiento.group(1) if vencimiento else None

    def extraer_linea_facturada(texto):
        """Extrae la línea facturada del texto de la factura."""
        patron_linea_facturada = r'LINEA FACTURADA\s*\((\d{2})\)\s*(\d{4}-\d{4})'
        linea_facturada = re.search(patron_linea_facturada, texto)
        return f"({linea_facturada.group(1)}) {linea_facturada.group(2)}" if linea_facturada else None

    #region 2
    def extraer_direccion(texto):
        """Extrae la dirección de la región 2 del texto de la factura."""
        # Patrón para capturar todo el texto que representa la dirección hasta "Piso"
        patron_direccion = r'^(.*?)(?=\s*Piso)'
        direccion = re.search(patron_direccion, texto, re.DOTALL)

        if direccion:
            # Limpiar la dirección y asegurarse de que esté en mayúsculas
            direccion_limpia = direccion.group(1).strip().upper()
            return direccion_limpia
        return None

    #region 3
    def extraer_numero_cliente(text):
        # Buscar el número de cliente usando una expresión regular
        match = re.search(r'Número de Cliente\s*(\d{10})', text)
        return match.group(1) if match else None

    def extraer_numero_factura(text):
        # Buscar el número de factura usando una expresión regular
        match = re.search(r'Factura N°\s*(\d{4}-\d{8})', text)
        return match.group(1) if match else None

    def extraer_fecha_emision(text):
        # Buscar la fecha de emisión usando una expresión regular
        match = re.search(r'Fecha de Emisión\s*(\d{2}/\d{2}/\d{4})', text)
        return match.group(1) if match else None

    #region 4
    def extraer_periodo(text):
        # Buscar todas las fechas en formato dd/mm/yy
        fechas = re.findall(r'\d{2}/\d{2}/\d{2}', text)

        # Convertir las fechas de dos dígitos a cuatro dígitos
        fechas_completas = []
        for fecha in fechas:
            dia, mes, año_corto = fecha.split('/')
            año_completo = '20' + año_corto if int(año_corto) < 100 else año_corto  # Asume que las fechas son del 2000 en adelante
            fechas_completas.append(f'{dia}/{mes}/{año_completo}')

        # Devolver la primera y última fecha si hay coincidencias
        if fechas_completas:
            primera_fecha = fechas_completas[0]
            ultima_fecha = fechas_completas[-1]
            return primera_fecha, ultima_fecha

        return None, None  # Si no se encuentran fechas


    # Extraer cada dato usando las funciones definidas
    df['Total'] = df['Region_1'].apply(extraer_total_a_pagar)
    df['Fecha de vencimiento'] = df['Region_1'].apply(extraer_vencimiento)
    df['Linea'] =df['Region_1'].apply(extraer_linea_facturada)
    df['Destinatario'] = df['Region_2'].apply(extraer_direccion)
    df['Cliente'] = df['Region_3'].apply(extraer_numero_cliente)
    df['Numero de factura'] = df['Region_3'].apply(extraer_numero_factura)
    df['Fecha de emision'] = df['Region_3'].apply(extraer_fecha_emision)
    df['Desde'] = df['Region_4'].apply(lambda x: extraer_periodo(x)[0])
    df['Hasta'] = df['Region_4'].apply(lambda x: extraer_periodo(x)[1])
    #df.head()

    """AGREGADOS"""
    def extraer_telefonogramas(filename):
        doc = fitz.open(filename)
        frase_referencia = "Telefonogramas"
        texto_extraido = ""

        for page_num in range(len(doc)):
            page = doc[page_num]
            text = page.get_text("text")

            # Verificamos si la frase está en el texto
            if frase_referencia in text:
                # Si se encuentra, obtenemos las coordenadas de la palabra
                rect = page.search_for(frase_referencia)

                for r in rect:
                    # Expandir la región para incluir solo la línea de "Telefonogramas" y la siguiente
                    texto_linea_telefonogramas = page.get_text("text", clip=fitz.Rect(0, r.y0, page.rect.width, r.y0 + 20))
                    texto_siguiente = page.get_text("text", clip=fitz.Rect(0, r.y1, page.rect.width, r.y1 + 20))

                    texto_extraido += texto_linea_telefonogramas.strip() + "\n" + texto_siguiente.strip() + "\n"

        doc.close()

        # Usar una expresión regular para encontrar el monto en el texto extraído
        monto = re.findall(r'\d{1,3}(?:\.\d{3})*,\d{2}', texto_extraido)

        # Devolver el primer monto encontrado si existe, si no, devolver None
        if monto:
            return monto[0]  # Devuelve el primer monto como texto
        else:
            return None  # Devuelve None si no se encontró ningún monto

    """LIMPIAR EL DATAFRAME"""
    df.drop(columns=['Region_1', 'Region_2', 'Region_3', 'Region_4'], inplace=True)
    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})-(\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)


    df[['sucursal','factura']] = df['Numero de factura'].apply(separar_codigo).apply(pd.Series)
    df.drop(columns=['Numero de factura'], inplace=True)
    df['Total'] = df['Total'].str.replace('.', '').str.replace(',','.').astype(float)
    df['Fecha de emision'] = pd.to_datetime(df['Fecha de emision'], format='%d/%m/%Y')
    df['Fecha de vencimiento'] = pd.to_datetime(df['Fecha de vencimiento'], format='%d/%m/%Y')
    df['Desde'] = pd.to_datetime(df['Desde'],format='%d/%m/%Y')
    df['Hasta'] = pd.to_datetime(df['Hasta'],format='%d/%m/%Y')
    df['sucursal'] = df['sucursal'].astype(int)
    df['factura'] = df['factura'].astype(int)
    df['Cliente'] = df['Cliente'].astype(int)
    df['Telefonogramas'] = df['Archivo'].apply(extraer_telefonogramas)
    df['Telefonogramas'] = df['Telefonogramas'].str.replace('.', '').str.replace(',','.')
    df['Telefonogramas'] = df['Telefonogramas'].astype(float)

    df.fillna(0, inplace=True)
    columnas_orden = ['sucursal', 'factura', 'Cliente','Linea', 'Fecha de emision','Fecha de vencimiento'
                      , 'Desde', 'Hasta', 'Telefonogramas','Total', 'Archivo', 'Destinatario']
    df = df[columnas_orden]
    #df.head()

    """exportar el dataframe"""
    nombre='TECO Facturas leidas.xlsx'
    df.to_excel(nombre, index = False)
    files.download(nombre)

def teco2_simple():
    # @title
    TECO2_regiones = [(370,55,570,140),(20,80,260,150),(20,155,380,205),(390,155,560,225)]

    """cargar el archivo y generar el df"""
    uploaded = files.upload()
    filename = list(uploaded.keys())[0]

    """extraer texto y armar el df"""
    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def procesar_varios_pdfs(lista_pdfs, regiones, pagina_numero=1):
        """
        Procesa varios archivos PDF y extrae las regiones definidas.

        Args:
        - lista_pdfs (list): Lista de rutas a los archivos PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).
        - pagina_numero (int): Número de la página a analizar (por defecto 1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada PDF.
        """
        # Lista para almacenar los datos de cada PDF
        datos_pdf = []

        # Iterar sobre cada archivo PDF
        for pdf_path in lista_pdfs:
            # Extraer texto de las regiones
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_pdf.append({
                "Archivo": pdf_path,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_pdf)

        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF
    regiones = TECO2_regiones  # Coordenadas de
    # Extraer texto de las regiones
    df = procesar_varios_pdfs(lista_pdfs ,regiones , 1)
    df_1 = df.copy
    df.head()

    """extraer datos de las regiones"""
    #region 1
    # Función para extraer el total a pagar
    def extraer_total(texto):
        # Ajustamos la regex para manejar espacios opcionales después del signo $
        total_pattern = r'TOTAL A PAGAR\s*\$?\s*([\d\.,]+)'
        total = re.search(total_pattern, texto)
        return total.group(1) if total else None

    # Función para extraer la fecha de vencimiento
    def extraer_vencimiento(texto):
        fecha_pattern = r'VENCIMIENTO\s*(\d{2}/\d{2}/\d{4})'
        fecha_vencimiento = re.search(fecha_pattern, texto)
        return fecha_vencimiento.group(1) if fecha_vencimiento else None

    # Función para extraer el periodo facturado
    def extraer_periodo(texto):
        periodo_pattern = r'PERIODO FACTURADO\s*(\d{2}/\d{2}/\d{4}) al (\d{2}/\d{2}/\d{4})'
        periodo_facturado = re.search(periodo_pattern, texto)
        if periodo_facturado:
            return periodo_facturado.group(1), periodo_facturado.group(2)
        return None, None

    # Función para extraer la línea facturada
    def extraer_linea(texto):
        # Ajustamos la regex para capturar números con saltos de línea, espacios, etc.
        linea_pattern = r'LÍNEA FACTURADA\s*\(?(\d{2})\)?\s*(\d{4,5})\s*(\d{4})'
        linea_facturada = re.search(linea_pattern, texto, re.DOTALL)
        if linea_facturada:
            return f"({linea_facturada.group(1)}){linea_facturada.group(2)}{linea_facturada.group(3)}"
        return None

    #region 2
    # Función para extraer la dirección
    def extraer_direccion(texto):
        # Patrón para capturar la dirección: Nombre de calle seguido de número y piso opcional
        direccion_pattern = r'([A-Z\s]+(?:AV|CALLE|CARRERA|PASAJE|RUTA)\s+\d+.*)'
        direccion = re.search(direccion_pattern, texto)
        return direccion.group(1).strip() if direccion else None

    #region 3

    # Función para extraer el saldo anterior
    def extraer_saldo(texto):
        patron_saldo = r"SALDO ANTERIOR\s*\$?\s*([\d\.,]+)"
        saldo = re.search(patron_saldo, texto)
        return saldo.group(1) if saldo else None

    # Función para extraer los cargos del mes
    def extraer_cargo(texto):
        patron_cargo = r"CARGOS DEL MES\s*\$?\s*([\d\.,]+)"
        cargo = re.search(patron_cargo, texto)
        return cargo.group(1) if cargo else None

    #region 4
    # Función para extraer el número de factura
    def extraer_numero_factura(texto):
        factura_pattern = r'Factura N°\s*(\d{5}-\d{8})'
        numero_factura = re.search(factura_pattern, texto)
        return numero_factura.group(1) if numero_factura else None

    # Función para extraer la fecha de emisión
    def extraer_fecha_emision(texto):
        fecha_pattern = r'Fecha de Emisión\s*(\d{2}/\d{2}/\d{4})'
        fecha_emision = re.search(fecha_pattern, texto)
        return fecha_emision.group(1) if fecha_emision else None

    def extraer_numero_referencia(texto):
        # Definir el patrón para buscar el número de referencia
        # Asumimos que es un número que sigue a "N° de Referencia de Pago"
        patron = r"N° de Referencia de Pago\s*(\d{16})"

        # Buscar el número de referencia en el texto
        coincidencia = re.search(patron, texto)

        # Retornar el número de referencia si se encuentra, de lo contrario None
        if coincidencia:
            return coincidencia.group(1)  # Retorna el número de referencia
        else:
            return None


    # Uso de las funciones para extraer los datos
    df['Total'] = df['Region_1'].apply (extraer_total)
    df['Vencimiento'] = df['Region_1'].apply (extraer_vencimiento)
    df['Desde'], df['Hasta'] = zip(*df['Region_1'].apply(extraer_periodo))
    df['Linea'] = df['Region_1'].apply(extraer_linea)
    df['Destinatario'] = df['Region_2'].apply(extraer_direccion)
    df['Saldo anterior'] = df['Region_3'].apply(extraer_saldo)
    df['Cargos del mes'] = df['Region_3'].apply(extraer_cargo)
    df['Numero de factura'] = df['Region_4'].apply(extraer_numero_factura)
    df['Fecha de Emision'] = df['Region_4'].apply(extraer_fecha_emision)
    df['Referencia'] = df['Region_4'].apply(extraer_numero_referencia)

    df.head()

    """adicionales"""
    def extraer_telefonogramas(filename):
        doc = fitz.open(filename)
        frase_referencia = "Telefonogramas"
        texto_extraido = ""

        for page_num in range(len(doc)):
            page = doc[page_num]
            text = page.get_text("text")

            # Verificamos si la frase está en el texto
            if frase_referencia in text:
                # Si se encuentra, obtenemos las coordenadas de la palabra
                rect = page.search_for(frase_referencia)

                for r in rect:
                    # Expandir la región para incluir solo la línea de "Telefonogramas" y la siguiente
                    texto_linea_telefonogramas = page.get_text("text", clip=fitz.Rect(0, r.y0, page.rect.width, r.y0 + 20))
                    texto_siguiente = page.get_text("text", clip=fitz.Rect(0, r.y1, page.rect.width, r.y1 + 20))

                    texto_extraido += texto_linea_telefonogramas.strip() + "\n" + texto_siguiente.strip() + "\n"

        doc.close()

        # Usar una expresión regular para encontrar el monto en el texto extraído
        montos = re.findall(r'\d{1,3}(?:\.\d{3})*,\d{2}', texto_extraido)

        # Devolver el primer monto encontrado si existe, si no, devolver None
        if montos:
            return float(montos[0].replace('.', '').replace(',', '.'))  # Devuelve el primer monto como número
        else:
            return None  # Devuelve None si no se encontró ningún monto


    df['Telefonogramas'] = df['Archivo'].apply(extraer_telefonogramas)
    df.head()
    """ajustar lass columnas"""
    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})-(\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)
        return "No encontrado", "No encontrado"

    df.drop(columns=['Region_1','Region_2','Region_3','Region_4'],inplace=True)
    df['Total'] = df['Total'].str.replace('.','').str.replace(',','.')
    df['Total'] = df['Total'].astype(float)
    df['Desde'] = pd.to_datetime(df['Desde'], format='%d/%m/%Y')
    df['Hasta'] = pd.to_datetime(df['Hasta'], format='%d/%m/%Y')
    df['Fecha de Emision'] = pd.to_datetime(df['Fecha de Emision'], format='%d/%m/%Y')
    df['Vencimiento'] = pd.to_datetime(df['Vencimiento'], format='%d/%m/%Y')
    df[['sucursal', 'factura']] = df['Numero de factura'].apply(separar_codigo).apply(pd.Series)
    df = df.drop(columns=['Numero de factura'])
    df['sucursal'] = df['sucursal'].astype(int)
    df['factura'] = df['factura'].astype(int)
    df['Telefonogramas'] = df['Telefonogramas'].astype(float)
    df['Referencia'] = df['Referencia'].astype(int)
    df['Saldo anterior'] = df['Saldo anterior'].str.replace('.','').str.replace(',','.')
    df['Cargos del mes'] = df['Cargos del mes'].str.replace('.','').str.replace(',','.')
    df['Saldo anterior'] = df['Saldo anterior'].astype(float)
    df['Cargos del mes'] = df['Cargos del mes'].astype(float)


    nuevo_orden= ['sucursal','factura','Referencia','Linea','Fecha de Emision', 'Vencimiento','Desde','Hasta','Saldo anterior','Cargos del mes','Telefonogramas','Total','Destinatario','Archivo']
    df = df[nuevo_orden]
    df.head()

    """exportar a excel"""
    nombre_archivo = 'TECO con telefonogramas facturas leidas.xlsx'
    df.to_excel(nombre_archivo, index=False)
    files.download(nombre_archivo)

def teco_unificado():
    # @title
    TECO_regiones = [(390,50,570,130),(30,80,250,150),(300,170,570,280),(95,300,350,390)]

    """cargar el archivo y generar el df"""
    uploaded = files.upload()
    filename = list(uploaded.keys())[0]

    """extraer texto y armar el df"""

    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def obtener_numero_paginas(pdf_path):
        """
        Obtiene el número total de páginas en un archivo PDF.

        Args:
        - pdf_path (str): Ruta al archivo PDF.

        Returns:
        - int: Número total de páginas en el PDF.
        """
        with fitz.open(pdf_path) as pdf:
            num_paginas = pdf.page_count
        return num_paginas


    def procesar_pdf_con_varias_paginas(pdf_path, regiones):
        """
        Procesa un archivo PDF con múltiples páginas y extrae las regiones definidas.

        Args:
        - pdf_path (str): Ruta al archivo PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada página del PDF.
        """
        # Lista para almacenar los datos de cada página del PDF
        datos_paginas = []

        # Obtener el número total de páginas del PDF
        num_paginas = obtener_numero_paginas(pdf_path)

        # Iterar sobre cada página del PDF
        for pagina_numero in range(1, num_paginas + 1):
            # Extraer texto de las regiones en la página actual
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_paginas.append({
                "Archivo": pdf_path,
                "Pagina": pagina_numero,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_paginas)
        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF
    file_path = next(iter(uploaded.keys()))
    regiones = TECO_regiones  # Coordenadas de
    # Extraer texto de las regiones
    df = procesar_pdf_con_varias_paginas(file_path ,regiones )

    # Suponiendo que 'df' es tu DataFrame y 'columna' es el nombre de la columna
    # y 'palabra' es la palabra que quieres buscar:

    # Convertir la columna a tipo string si no lo es
    df['Region_1'] = df['Region_1'].astype(str)

    # Usar una expresión regular para buscar la palabra en la columna
    # ignorando mayúsculas y minúsculas
    df = df[df['Region_1'].str.contains(r"\bTOTAL A PAGAR\b", case=False, na=False)]
    #print(df['Region_1'])

    """extraer los datos de las regiones"""

    #df.head()
    #region 1
    def extraer_total_a_pagar(texto):
        """Extrae el total a pagar del texto de la factura."""
        patron_total = r'TOTAL A PAGAR\s*([\d.,]+)'
        total = re.search(patron_total, texto)
        return total.group(1) if total else None

    def extraer_vencimiento(texto):
        """Extrae la fecha de vencimiento del texto de la factura."""
        patron_vencimiento = r'VENCIMIENTO\s*(\d{2}/\d{2}/\d{4})'
        vencimiento = re.search(patron_vencimiento, texto)
        return vencimiento.group(1) if vencimiento else None

    def extraer_linea_facturada(texto):
        """Extrae la línea facturada del texto de la factura."""
        patron_linea_facturada = r'LINEA FACTURADA\s*\((\d{2})\)\s*(\d{4}-\d{4})'
        linea_facturada = re.search(patron_linea_facturada, texto)
        return f"({linea_facturada.group(1)}) {linea_facturada.group(2)}" if linea_facturada else None

    #region 2
    def extraer_direccion(texto):
        """Extrae la dirección de la región 2 del texto de la factura."""
        # Patrón para capturar todo el texto que representa la dirección hasta "Piso"
        patron_direccion = r'^(.*?)(?=\s*Piso)'
        direccion = re.search(patron_direccion, texto, re.DOTALL)

        if direccion:
            # Limpiar la dirección y asegurarse de que esté en mayúsculas
            direccion_limpia = direccion.group(1).strip().upper()
            return direccion_limpia
        return None

    #region 3
    def extraer_numero_cliente(text):
        # Buscar el número de cliente usando una expresión regular
        match = re.search(r'Número de Cliente\s*(\d{10})', text)
        return match.group(1) if match else None

    def extraer_numero_factura(text):
        # Buscar el número de factura usando una expresión regular
        match = re.search(r'Factura N°\s*(\d{4}-\d{8})', text)
        return match.group(1) if match else None

    def extraer_fecha_emision(text):
        # Buscar la fecha de emisión usando una expresión regular
        match = re.search(r'Fecha de Emisión\s*(\d{2}/\d{2}/\d{4})', text)
        return match.group(1) if match else None

    #region 4
    import re

    def extraer_periodo(text):
        # Buscar todas las fechas en formato dd/mm/yy
        fechas = re.findall(r'\d{2}/\d{2}/\d{2}', text)

        # Convertir las fechas de dos dígitos a cuatro dígitos
        fechas_completas = []
        for fecha in fechas:
            dia, mes, año_corto = fecha.split('/')
            año_completo = '20' + año_corto if int(año_corto) < 100 else año_corto  # Asume que las fechas son del 2000 en adelante
            fechas_completas.append(f'{dia}/{mes}/{año_completo}')

        # Devolver la primera y última fecha si hay coincidencias
        if fechas_completas:
            primera_fecha = fechas_completas[0]
            ultima_fecha = fechas_completas[-1]
            return primera_fecha, ultima_fecha

        return None, None  # Si no se encuentran fechas


    # Extraer cada dato usando las funciones definidas
    df['Total'] = df['Region_1'].apply(extraer_total_a_pagar)
    df['Fecha de vencimiento'] = df['Region_1'].apply(extraer_vencimiento)
    df['Linea'] =df['Region_1'].apply(extraer_linea_facturada)
    df['Destinatario'] = df['Region_2'].apply(extraer_direccion)
    df['Cliente'] = df['Region_3'].apply(extraer_numero_cliente)
    df['Numero de factura'] = df['Region_3'].apply(extraer_numero_factura)
    df['Fecha de emision'] = df['Region_3'].apply(extraer_fecha_emision)
    df['Desde'] = df['Region_4'].apply(lambda x: extraer_periodo(x)[0])
    df['Hasta'] = df['Region_4'].apply(lambda x: extraer_periodo(x)[1])
    #df.head()

    """AGREGADOS"""
    import fitz
    import re

    def extraer_telefonogramas(pagina_actual, paginas_lista):
        # Ruta fija del documento PDF
        pdf_path = file_path  # Cambia esta ruta a tu archivo PDF
        doc = fitz.open(pdf_path)

        # Definir el texto a buscar
        text_to_find = "Telefonogramas"

        # Determinar el índice de la página actual
        try:
            index_actual = paginas_lista.index(pagina_actual)
        except ValueError:
            doc.close()
            return None

        # Determinar la siguiente página, si existe
        pagina_siguiente = paginas_lista[index_actual + 1] if index_actual + 1 < len(paginas_lista) else None

        # Iterar sobre las páginas desde la actual hasta la siguiente
        for page_num in range(pagina_actual - 1, (pagina_siguiente or pagina_actual) - 1):
            page = doc[page_num]

            # Buscar el texto "Telefonogramas" y obtener sus coordenadas
            text_instances = page.search_for(text_to_find)

            # Si se encuentran instancias del texto, procesar
            if text_instances:
                for inst in text_instances:
                    # Obtener la línea de texto donde se encuentra "Telefonogramas"
                    rect = fitz.Rect(inst)

                    # Expandir el rectángulo en el eje X para incluir toda la línea
                    expanded_rect = fitz.Rect(0, rect.y0, page.rect.width, rect.y1 + 20)

                    # Extraer el texto dentro del rectángulo expandido
                    extracted_text = page.get_text("text", clip=expanded_rect)

                    # Definir el patrón para encontrar montos
                    pattern = r'\b\d{1,3}(?:\.\d{3})*,\d{2}\b'

                    # Buscar todos los posibles montos dentro del texto extraído
                    matches = re.findall(pattern, extracted_text)

                    # Filtrar los montos encontrados y devolver el último
                    if matches:
                        monto = matches[-1].replace('.', '').replace(',', '.')  # Normalizamos el formato del monto
                        doc.close()  # Cerramos el documento
                        return monto

        # Cerrar el documento si no se encuentra ningún monto
        doc.close()
        return None


    """LIMPIAR EL DATAFRAME"""
    df.drop(columns=['Region_1', 'Region_2', 'Region_3', 'Region_4'], inplace=True)
    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})-(\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)

    df[['sucursal','factura']] = df['Numero de factura'].apply(separar_codigo).apply(pd.Series)
    df.drop(columns=['Numero de factura'], inplace=True)
    df['Total'] = df['Total'].str.replace('.', '').str.replace(',','.').astype(float)
    df['Fecha de emision'] = pd.to_datetime(df['Fecha de emision'], format='%d/%m/%Y')
    df['Fecha de vencimiento'] = pd.to_datetime(df['Fecha de vencimiento'], format='%d/%m/%Y')
    df['Desde'] = pd.to_datetime(df['Desde'],format='%d/%m/%Y')
    df['Hasta'] = pd.to_datetime(df['Hasta'],format='%d/%m/%Y')
    df['sucursal'] = df['sucursal'].astype(int)
    df['factura'] = df['factura'].astype(int)
    df['Cliente'] = df['Cliente'].astype(int)
    df['Telefonogramas'] = df['Pagina'].apply(lambda pagina: extraer_telefonogramas(pagina, df['Pagina'].tolist()))
    df['Telefonogramas'] = df['Telefonogramas'].astype(float)
    df.fillna(0, inplace=True)

    columnas_orden = ['sucursal', 'factura', 'Cliente','Linea', 'Fecha de emision','Fecha de vencimiento'
                      , 'Desde', 'Hasta', 'Telefonogramas','Total', 'Pagina', 'Destinatario']
    df = df[columnas_orden]
    #df.head()

    """ADICIONALES"""
    def encontrar_saltos(paginas):
        saltos = []
        for i in range(1, len(paginas)):
            diferencia = paginas[i] - paginas[i - 1]
            if diferencia > 2:
                saltos.append((paginas[i - 1], paginas[i]))
        return saltos

    # Ejemplo de uso
    paginas = df['Pagina'].tolist()
    saltos_encontrados = encontrar_saltos(paginas)
    print("Saltos encontrados entre las siguientes páginas:")
    for inicio, fin in saltos_encontrados:
        print(f"Entre {inicio} y {fin}")


    """exportar el dataframe"""
    nombre='TECO Facturas leidas.xlsx'
    df.to_excel(nombre, index = False)
    files.download(nombre)

def teco2_unificado():
    # @title
    TECO2_regiones = [(370,55,570,140),(20,80,260,150),(20,155,380,205),(390,155,560,225)]

    """cargar el archivo y generar el df"""
    uploaded = files.upload()
    filename = list(uploaded.keys())[0]

    """extraer texto y armar el df"""

    def extraer_texto_regiones(pdf_path, pagina_numero, regiones):
        """
        Extrae texto de varias regiones de una página de un archivo PDF.

        Args:
        - pdf_path (str): Ruta del archivo PDF.
        - pagina_numero (int): Número de la página del PDF (1-indexed).
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1) para extraer texto.

        Returns:
        - dict: Diccionario con el texto extraído de cada región.
        """
        # Abrir el documento PDF con PyMuPDF
        pdf_documento = fitz.open(pdf_path)

        if pagina_numero < 1 or pagina_numero > pdf_documento.page_count:
            print(f"Error: La página {pagina_numero} no existe en el PDF.")
            return {}

        # Cargar la página correspondiente
        pagina = pdf_documento.load_page(pagina_numero - 1)

        # Diccionario para almacenar el texto de cada región
        textos_regiones = {}

        # Extraer texto de cada región
        for idx, region in enumerate(regiones):
            # Obtener la región como una subpágina recortada
            clip = fitz.Rect(region)  # Crear un rectángulo para la región
            pagina_recortada = pagina.get_text("text", clip=clip)  # Extraer texto en esa región
            textos_regiones[f"Region_{idx+1}"] = pagina_recortada

        # Cerrar el documento PDF
        pdf_documento.close()

        return textos_regiones

    def obtener_numero_paginas(pdf_path):
        """
        Obtiene el número total de páginas en un archivo PDF.

        Args:
        - pdf_path (str): Ruta al archivo PDF.

        Returns:
        - int: Número total de páginas en el PDF.
        """
        with fitz.open(pdf_path) as pdf:
            num_paginas = pdf.page_count
        return num_paginas


    def procesar_pdf_con_varias_paginas(pdf_path, regiones):
        """
        Procesa un archivo PDF con múltiples páginas y extrae las regiones definidas.

        Args:
        - pdf_path (str): Ruta al archivo PDF.
        - regiones (list): Lista de regiones con coordenadas (x0, y0, x1, y1).

        Returns:
        - DataFrame: DataFrame con los datos extraídos de cada página del PDF.
        """
        # Lista para almacenar los datos de cada página del PDF
        datos_paginas = []

        # Obtener el número total de páginas del PDF
        num_paginas = obtener_numero_paginas(pdf_path)

        # Iterar sobre cada página del PDF
        for pagina_numero in range(1, num_paginas + 1):
            # Extraer texto de las regiones en la página actual
            texto_regiones = extraer_texto_regiones(pdf_path, pagina_numero, regiones)

            # Agregar los datos al diccionario
            datos_paginas.append({
                "Archivo": pdf_path,
                "Pagina": pagina_numero,
                **texto_regiones
            })

        # Convertir los datos a un DataFrame
        df = pd.DataFrame(datos_paginas)
        return df

    # Ejemplo de uso con varios archivos PDF
    lista_pdfs = list(uploaded.keys())  # Lista de rutas a los archivos PDF
    file_path = next(iter(uploaded.keys()))
    regiones = TECO2_regiones  # Coordenadas de
    # Extraer texto de las regiones
    df = procesar_pdf_con_varias_paginas(file_path ,regiones )
    #df.head(20)
    df.drop(df[df['Region_1'].isna() | df['Region_1'].str.strip().eq('')].index, inplace=True)
    """extraer datos de las regiones"""
    #region 1
    # Función para extraer el total a pagar
    def extraer_total(texto):
        # Ajustamos la regex para manejar espacios opcionales después del signo $
        total_pattern = r'TOTAL A PAGAR\s*\$?\s*([\d\.,]+)'
        total = re.search(total_pattern, texto)
        return total.group(1) if total else None

    # Función para extraer la fecha de vencimiento
    def extraer_vencimiento(texto):
        fecha_pattern = r'VENCIMIENTO\s*(\d{2}/\d{2}/\d{4})'
        fecha_vencimiento = re.search(fecha_pattern, texto)
        return fecha_vencimiento.group(1) if fecha_vencimiento else None

    # Función para extraer el periodo facturado
    def extraer_periodo(texto):
        periodo_pattern = r'PERIODO FACTURADO\s*(\d{2}/\d{2}/\d{4}) al (\d{2}/\d{2}/\d{4})'
        periodo_facturado = re.search(periodo_pattern, texto)
        if periodo_facturado:
            return periodo_facturado.group(1), periodo_facturado.group(2)
        return None, None

    # Función para extraer la línea facturada
    def extraer_linea(texto):
        # Ajustamos la regex para capturar números con saltos de línea, espacios, etc.
        linea_pattern = r'LÍNEA FACTURADA\s*\(?(\d{2})\)?\s*(\d{4,5})\s*(\d{4})'
        linea_facturada = re.search(linea_pattern, texto, re.DOTALL)
        if linea_facturada:
            return f"({linea_facturada.group(1)}){linea_facturada.group(2)}{linea_facturada.group(3)}"
        return None

    #region 2
    # Función para extraer la dirección
    def extraer_direccion(texto):
        # Patrón para capturar la dirección: Nombre de calle seguido de número y piso opcional
        direccion_pattern = r'([A-Z\s]+(?:AV|CALLE|CARRERA|PASAJE|RUTA)\s+\d+.*)'
        direccion = re.search(direccion_pattern, texto)
        return direccion.group(1).strip() if direccion else None

    #region 3
    # Función para extraer el saldo anterior
    def extraer_saldo(texto):
        patron_saldo = r"SALDO ANTERIOR\s*\$?\s*([\d\.,]+)"
        saldo = re.search(patron_saldo, texto)
        return saldo.group(1) if saldo else None

    # Función para extraer los cargos del mes
    def extraer_cargo(texto):
        patron_cargo = r"CARGOS DEL MES\s*\$?\s*([\d\.,]+)"
        cargo = re.search(patron_cargo, texto)
        return cargo.group(1) if cargo else None

    #region 4
    # Función para extraer el número de factura
    def extraer_numero_factura(texto):
        factura_pattern = r'Factura N°\s*(\d{5}-\d{8})'
        numero_factura = re.search(factura_pattern, texto)
        return numero_factura.group(1) if numero_factura else None

    # Función para extraer la fecha de emisión
    def extraer_fecha_emision(texto):
        fecha_pattern = r'Fecha de Emisión\s*(\d{2}/\d{2}/\d{4})'
        fecha_emision = re.search(fecha_pattern, texto)
        return fecha_emision.group(1) if fecha_emision else None

    #funcion para extraer el numero de referencia
    def extraer_numero_referencia(texto):
        # Definir el patrón para buscar el número de referencia
        # Asumimos que es un número que sigue a "N° de Referencia de Pago"
        patron = r"N° de Referencia de Pago\s*(\d{16})"

        # Buscar el número de referencia en el texto
        coincidencia = re.search(patron, texto)

        # Retornar el número de referencia si se encuentra, de lo contrario None
        if coincidencia:
            return coincidencia.group(1)  # Retorna el número de referencia
        else:
            return None

    # Uso de las funciones para extraer los datos
    df['Total'] = df['Region_1'].apply (extraer_total)
    df['Vencimiento'] = df['Region_1'].apply (extraer_vencimiento)
    df['Desde'], df['Hasta'] = zip(*df['Region_1'].apply(extraer_periodo))
    df['Linea'] = df['Region_1'].apply(extraer_linea)
    df['Destinatario'] = df['Region_2'].apply(extraer_direccion)
    df['Saldo anterior'] = df['Region_3'].apply(extraer_saldo)
    df['Cargos del mes'] = df['Region_3'].apply(extraer_cargo)
    df['Numero de factura'] = df['Region_4'].apply(extraer_numero_factura)
    df['Fecha de Emision'] = df['Region_4'].apply(extraer_fecha_emision)
    df['Referencia'] = df['Region_4'].apply(extraer_numero_referencia)
    #df.head()

    """adicionales"""
    def extraer_telefonogramas(page_num):
          # Asegúrate de definir el nombre del archivo
        doc = fitz.open(filename)
        frase_referencia = "Telefonogramas"
        texto_extraido = ""

        # Usamos el número de página proporcionado directamente
        page = doc[page_num - 1]  # Ajustamos para que coincida con la numeración del PDF
        text = page.get_text("text")

        # Verificamos si la frase está en el texto
        if frase_referencia in text:
            # Si se encuentra, obtenemos las coordenadas de la palabra
            rect = page.search_for(frase_referencia)

            for r in rect:
                # Expandir la región para incluir solo la línea de "Telefonogramas" y la siguiente
                texto_linea_telefonogramas = page.get_text("text", clip=fitz.Rect(0, r.y0, page.rect.width, r.y0 + 20))
                texto_siguiente = page.get_text("text", clip=fitz.Rect(0, r.y1, page.rect.width, r.y1 + 20))

                # Combinar el texto extraído
                texto_extraido += texto_linea_telefonogramas.strip() + "\n" + texto_siguiente.strip() + "\n"

        doc.close()

        # Usar una expresión regular para encontrar el monto
        montos = re.findall(r'\d{1,3}(?:\.\d{3})*,\d{2}', texto_extraido)

        # Convertir el primer monto encontrado a formato numérico, o devolver None si no hay montos
        if montos:
            return float(montos[0].replace('.', '').replace(',', '.'))  # Devuelve el primer monto como número
        else:
            return None  # Devuelve None si no se encontró ningún monto

    df['Telefonogramas'] = df['Pagina'].apply(extraer_telefonogramas)
    #df.head()

    """ajustar lass columnas"""
    def separar_codigo(numero_factura):
        match = re.search(r'(\d{4})-(\d{8})', numero_factura)
        if match:
            return match.group(1), match.group(2)
        return "No encontrado", "No encontrado"

    df.drop(columns=['Region_1','Region_2','Region_3','Region_4'],inplace=True)
    df['Total'] = df['Total'].str.replace('.','').str.replace(',','.')
    df['Total'] = df['Total'].astype(float)
    df['Desde'] = pd.to_datetime(df['Desde'], format='%d/%m/%Y')
    df['Hasta'] = pd.to_datetime(df['Hasta'], format='%d/%m/%Y')
    df['Fecha de Emision'] = pd.to_datetime(df['Fecha de Emision'], format='%d/%m/%Y')
    df['Vencimiento'] = pd.to_datetime(df['Vencimiento'], format='%d/%m/%Y')
    df[['sucursal', 'factura']] = df['Numero de factura'].apply(separar_codigo).apply(pd.Series)
    df = df.drop(columns=['Numero de factura'])
    df['sucursal'] = df['sucursal'].astype(int)
    df['factura'] = df['factura'].astype(int)
    df['Telefonogramas'] = df['Telefonogramas'].astype(float)
    df['Referencia'] = df['Referencia'].astype(int)
    df['Saldo anterior'] = df['Saldo anterior'].str.replace('.','').str.replace(',','.')
    df['Saldo anterior'] = df['Saldo anterior'].astype(float)
    df['Cargos del mes'] = df['Cargos del mes'].str.replace('.','').str.replace(',','.')
    df['Cargos del mes'] = df['Cargos del mes'].astype(float)


    nuevo_orden= ['sucursal','factura','Referencia','Linea','Fecha de Emision', 'Vencimiento','Desde','Hasta','Saldo anterior','Cargos del mes','Telefonogramas','Total','Destinatario','Pagina']
    df = df[nuevo_orden]
    df.head()

    """exportar a excel"""
    nombre_archivo = 'TECO con telefonogramas facturas leidas.xlsx'
    df.to_excel(nombre_archivo, index=False)
    files.download(nombre_archivo)

